<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数学全家桶之数论函数</title>
    <url>/2020/01/14/%E6%95%B0%E5%AD%A6%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8B%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<div class="note default">
            <p>本章主要讲解了几个主要的数论函数及应用, 如果我学到了一些新的奇技淫巧可能会更新</p>
          </div>
<a id="more"></a>
<h3 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h3><p>对于实数x, 记$\lfloor x \rfloor$为不超过x的最大整数</p>
<p>$\lfloor x \rfloor$ 是满足下列关系的唯一整数</p>
<script type="math/tex; mode=display">
x-1 < \lfloor x \rfloor \leq x < \lfloor x \rfloor + 1</script><p>其他性质: </p>
<ul>
<li>对于正整数n, 1 到 n 中 d 的倍数有 $ \lfloor \frac{n}{d} \rfloor $个</li>
<li>$\lfloor \frac {\lfloor \frac{x}{a} \rfloor}{b}  \rfloor = \lfloor \frac{x}{ab} \rfloor$</li>
<li>对于正整数n, d(小于等于n), $\lfloor \frac{n}{d} \rfloor$ 的不同取值个数不超过$2 \sqrt n$ </li>
</ul>
<h4 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块:"></a>整除分块:</h4><p>若$\lfloor \frac{n}{a} \rfloor$与$\lfloor \frac{n}{b} \rfloor$相等, 则a的最大值为$\large \left \lfloor \frac N{\left \lfloor \frac Nb \right \rfloor } \right \rfloor$</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r;l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    r = n / (n / i);</span><br><span class="line">    <span class="keyword">do</span> something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>证明</p>
<p>学习了<a href="https://blog.csdn.net/u013700358/article/details/97166124" target="_blank" rel="noopener">这篇博客</a></p>
<script type="math/tex; mode=display">
设\lfloor \frac{N}{b} \rfloor = p, 则N = pb + q \\
若存在d, 使得\lfloor \frac{N}{b + d} \rfloor = p, 则N = p(b+d) + q' \\
pb+q = pb + pd + q' \\
d = \frac qp - \frac {q'}p \\
d_{max} = \lfloor \frac{q}{p} \rfloor \\
a_{max} = b + d_{max} = b + \lfloor \frac{q}{p} \rfloor = \lfloor \frac{pb + N - pb}{p} \rfloor = \large  \left \lfloor \frac{N}{\lfloor \frac{N}{b} \rfloor} \right \rfloor</script><h3 id="调和数"><a href="#调和数" class="headerlink" title="调和数"></a>调和数</h3><p>定义: $H_n = \displaystyle \sum_{k=1}^n \frac1k$</p>
<p>$H_n = ln(H+1) + \gamma$ 其中$\gamma \approx 0.5772156649$</p>
<h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数 :"></a>积性函数 :</h3><p>对于数论函数f(x), 对于互质两数a, b, f(ab) = f(a) * f(b)</p>
<p>特殊的,对于a, b不互质也满足上式, 则称f(x)为完全积性函数</p>
<h4 id="常见积性函数"><a href="#常见积性函数" class="headerlink" title="常见积性函数"></a>常见积性函数</h4><ol>
<li>μ(n)——莫比乌斯函数。<script type="math/tex">\mu(d)=\begin{cases} 1 &\text{d = 1}\\ (-1)^r &\text{$d=p_1p_2...p_r,其中p_i为素数$}\\ 0 &\text{others} \end{cases}</script> </li>
<li>φ(n)——欧拉函数。表示不大于n且与n互质的正整数个数，十分常见的数论函数。用数学式子表示即：φ(n) = $\sum^{n}_{d=1}[gcd(d, n) == 1]$;</li>
<li>d(n)——约数个数。表示n的约数的个数。用式子表示为：d(n) = $\sum^n_{d = 1} [d |n]$;</li>
<li><p>σ(n)——约数和函数。 即n的各个约数之和。表示为：σ(n)  = $\sum_{d|n}d$  = $\sum^{n}_{d = 1} [d | n] \cdot d$ ; </p>
<p>(PS：接下来列举的是完全积性函数)</p>
</li>
<li><p>ϵ(n)——元函数。ϵ(n) = [n=1]。</p>
</li>
<li>I(n)——恒等函数。所谓恒等就是这个函数的值恒为1。</li>
<li>id(n)——单位函数。id(n)=n。</li>
</ol>
<h3 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积 :"></a>狄利克雷卷积 :</h3><p>设f , g为数论函数, 其狄利克雷卷积为 $f * g = \sum_{d | n} f(d) \cdot g(n / d)$ </p>
<p>其性质满足交换律, 结合律和分配律</p>
<p>几条比较常用的小性质 :</p>
<h4 id="单位元-f-epsilon-f"><a href="#单位元-f-epsilon-f" class="headerlink" title="单位元 : $f * \epsilon = f$"></a>单位元 : $f * \epsilon = f$</h4><h4 id="莫比乌斯反演-mu-I-epsilon"><a href="#莫比乌斯反演-mu-I-epsilon" class="headerlink" title="莫比乌斯反演 $\mu * I = \epsilon$"></a>莫比乌斯反演 $\mu * I = \epsilon$</h4><div class="note default">
            <p>证明 : </p><p>若 n &gt; 1</p><script type="math/tex; mode=display">\mu * I = \sum_{d | n} \mu(d),    设 n = p^{\alpha_1}_1p^{\alpha_2}_2 \cdots p^{\alpha_k}_k</script><p>因为含有平方因子的\mu值一定为零,  所以我们只考虑每个质因子选一个或不选</p><p>然后根据组合数选奇数项之和等于选偶数项之和(也可以用二项式定理), 得出$\mu * I = 0$</p><p>若n = 1, $\mu * I = 1$</p><p>证毕</p>
          </div>
<h4 id="欧拉函数相关-n-phi-I"><a href="#欧拉函数相关-n-phi-I" class="headerlink" title="欧拉函数相关 $ n = \phi * I $"></a>欧拉函数相关 $ n = \phi * I $</h4><p>例题: <a href="https://www.luogu.com.cn/problem/P2257" target="_blank" rel="noopener">yy的gcd</a></p>
<p>从经典的问题谈起: 有多少对(x,y)使得$x \leq n , y \leq m ~gcd(x, y) = 1$</p>
<script type="math/tex; mode=display">
\sum_{x=1}^n\sum_{y=1}^m[gcd(x, y)~=~1] = \sum_{x=1}^n\sum_{y=1}^m\sum_{d|gcd(x,y)}\mu(d)
\\
=\sum_{x=1}\sum^m_{y=1}\sum_{d|x,d|y}\mu(d)
\\
=\sum_{d=1}^{min(n,m)}\mu(d) \lfloor \frac nd \rfloor \lfloor \frac md \rfloor
$$ {\displaystyle}


回到本问题</script><p>\sum_{p \in P}\sum_{x=1}^n\sum_{y=1}^m[gcd(x, y)~=~p]  = \sum_{p \in P}\sum_{x=1}^{\lfloor \frac np \rfloor}\sum_{y=1}^{\lfloor \frac mp \rfloor}[gcd(x, y)~=~1]<br>\\<br>=\sum_{p \in P}\sum_{x=1}^{\lfloor \frac np \rfloor}\sum_{y=1}^{\lfloor \frac mp \rfloor}\sum_{d|x,d|y}\mu(d)<br>\\<br>=\sum_{p \in P} \sum_{d=1}^{\frac {min(n,m)}{p}}\mu(d) \lfloor \frac n{pd} \rfloor \lfloor \frac m{md} \rfloor<br>\\<br>= \sum_{t = 1}^{min(n, m)} \lfloor \frac nt \rfloor \lfloor \frac mt \rfloor \sum_{p \in P, p | t} \mu(\frac{t}{p})</p>
<p>$$</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>数学全家桶之数论筛法</title>
    <url>/2020/01/14/%E6%95%B0%E5%AD%A6%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8B%E6%95%B0%E8%AE%BA%E7%AD%9B%E6%B3%95/</url>
    <content><![CDATA[<div class="note default">
            <p>本章主要介绍了几个常用的数论筛法, 由浅入深, 如果有我学过的新筛法会持续更新</p>
          </div>
<a id="more"></a>
<h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛:"></a>素数筛:</h2><p>几条关于素数的小性质:</p>
<ul>
<li>1 ~ N中大约有 $\frac{N}{logN}$ 个素数</li>
</ul>
<h3 id="1-埃氏筛"><a href="#1-埃氏筛" class="headerlink" title="1. 埃氏筛"></a>1. 埃氏筛</h3><p>对于一个数x(x &gt; 1), x的倍数除x以外一定不是质数, 因为这个数可以分解为两个数相乘</p>
<p>利用这个原理, 设数组vis[x]表示x是否为质数, 从2枚举到n, 把每个数的倍数除它本身外标记为”不是质数”</p>
<p>对于x, 如果它不是任意小于它的数的倍数即没有被标记过, 那它就是个质数</p>
<p>时间复杂度 $\Theta(nlogn)$</p>
<p>可以有个优化, 就是合数不用枚举倍数, 因为小于它的质数一定会把它的倍数筛掉</p>
<p>时间复杂度 $\Theta(nloglongn)$</p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    prime[++tot] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i;j &lt;= n; j += i) </span><br><span class="line">        vis[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-线性筛"><a href="#2-线性筛" class="headerlink" title="2. 线性筛"></a>2. 线性筛</h3><p>观察发现有些数被筛了好几回, 如12被2, 3同时筛过</p>
<p>如果我们能利用每个数的特征来让每个数只被筛一次, 那么复杂度将变得更优</p>
<p>这个特征可以是每个数的最小质因子</p>
<p>设计e[x]数组表示x的最小质因子是谁, prime数组存储已经筛到的质数, 从2枚举到n, 假如当前数为x, 其最小质因子为p, 对于prime数组中所有小于等于p的质数$p_i$, 让$e[x \cdot p_i] = p_i$ </p>
<p>尝试用递归的方式理解: 例如数字$30 = 2 <em> 3 </em> 5$, 30的最小质因子是2, 所以它是被15筛掉的, $15 = 3 * 5$, 最小质因子为3, 它是被5筛掉的</p>
<p>时间复杂度 $\Theta(n)$, 其他应用: 筛次小质因子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!e[i]) e[i] = i, prime[++tot] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= tot &amp;&amp; prime[j] * i &lt;= n; j++) &#123;</span><br><span class="line">        e[i * prime[j]] = prime[j];</span><br><span class="line">        <span class="keyword">if</span> (prime[j] &gt;= e[i]) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数论筛法"><a href="#数论筛法" class="headerlink" title="数论筛法:"></a>数论筛法:</h2><hr>
]]></content>
  </entry>
  <entry>
    <title>虚树学习笔记</title>
    <url>/2020/01/01/%E8%99%9A%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>以消耗战为例</p>
<p>显然可以树形dp， 但时间复杂度爆炸</p>
<p>观察发现$\sum k$的值不是很大，假设只有两个点x， y，它们的公共祖先lca， 树形dp就像分别枚举割断它们到lca的每一条边，事实上我们一下子$ans = min(mn[lca], mn[x] + mn[y])$就可以算出来，这是因为他们之间有大量的无用的点</p>
<p>所以建一棵虚树来保留对答案可能有影响的关键点，询问点和一些lca</p>
<p>具体来说就是类似维护极右链似的， 每次把lca搞到栈里，还是看代码吧</p>
<a id="more"></a>
<p>还需要多做些题理解一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005000</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span> (f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], ne[N], to[N];</span><br><span class="line"><span class="keyword">int</span> w[N], dep[N], tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    ne[++tot] = h[x], to[tot] = y;</span><br><span class="line">    w[tot] = z, h[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> siz[N], f[N], son[N];</span><br><span class="line"><span class="keyword">int</span> Top[N], a[N], s[N], top;</span><br><span class="line">ll mn[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>, f[x] = fa, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i; i = ne[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = to[i]; <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        mn[y] = min(mn[x], (ll)w[i]);</span><br><span class="line">        dfs1(y, x), siz[x] += siz[y];</span><br><span class="line">        <span class="keyword">if</span> (siz[y] &gt; siz[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">    Top[x] = topf, dfn[x] = ++num;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i; i = ne[i]) </span><br><span class="line">        <span class="keyword">if</span> (!dfn[to[i]]) dfs2(to[i], to[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Top[x] != Top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[Top[x]] &lt; dep[Top[y]]) swap(x, y);</span><br><span class="line">        x = f[Top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[a] &lt; dfn[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_e</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    v[x].push_back(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(s[++top] = x);</span><br><span class="line">    <span class="keyword">int</span> lca = Lca(x, s[top]); </span><br><span class="line">    <span class="keyword">if</span> (lca == s[top]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dfn[s[top<span class="number">-1</span>]] &gt;= dfn[lca]) add_e(s[top<span class="number">-1</span>], s[top]), top--;</span><br><span class="line">    <span class="keyword">if</span> (lca != s[top]) add_e(lca, s[top]), s[top] = lca;</span><br><span class="line">    s[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!v[x].size()) <span class="keyword">return</span> mn[x];</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v[x].size(); i++)  sum += dp(v[x][i]);</span><br><span class="line">    v[x].clear(); <span class="keyword">return</span> min(sum, mn[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z; read(x), read(y), read(z);</span><br><span class="line">        add(x, y, z); add(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    mn[<span class="number">1</span>] = <span class="number">1l</span>l &lt;&lt; <span class="number">50</span>, dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    read(m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k; read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k; i++) read(a[i]);</span><br><span class="line">        sort(a + <span class="number">1</span>, a + k + <span class="number">1</span>, cmp);</span><br><span class="line">        s[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k; i++) ins(a[i]);</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span>) add_e(s[top - <span class="number">1</span>], s[top]), top--;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, dp(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>树上问题</category>
        <category>虚树</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>毒瘤养成记1: 如何卡hash</title>
    <url>/2019/12/31/%E6%AF%92%E7%98%A4%E5%85%BB%E6%88%90%E8%AE%B01-%E5%A6%82%E4%BD%95%E5%8D%A1hash/</url>
    <content><![CDATA[<div class="note default">
            <p>各位毒瘤大家好, 最近模拟赛考了一道trie+主席树好题, 但大家都用hash水过了这道题(<del>包括我</del>), 为了测试一下新搭建的HEAT OJ的hack功能,  <del>我将继续扮演毒瘤的角色, 用毒瘤的艺术形象努力创0造一个正能量的形象, 文体两开花, 弘扬中华文化,</del> 右转去BZOJ搞了一晚上hashkiller, 回来卡了单哈希(双哈希是真滴卡不住</p>
          </div>
<a id="more"></a>
<h2 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希(hash) :"></a>哈希(hash) :</h2><p>利用大质数或其他对应函数把字符串转为一个正整数来快速判断字符串相等</p>
<p>通常可以模一个大质数或使用自然溢出</p>
<p>实现(例);</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> di = <span class="number">1331</span>;</span><br><span class="line">hash[i] = (hash[i<span class="number">-1</span>] * base + s[i]) % P;</span><br></pre></td></tr></table></figure>
<p>其中$base$, 我称之为底数, P我称之为模数, 事实上自然溢出相当于模了$2^{64}$</p>
<h2 id="卡哈希的思想"><a href="#卡哈希的思想" class="headerlink" title="卡哈希的思想:"></a>卡哈希的思想:</h2><ol>
<li>数学构造</li>
<li>随机数据(依据生日悖论</li>
</ol>
<h2 id="Part-1-生日悖论"><a href="#Part-1-生日悖论" class="headerlink" title="Part 1 生日悖论:"></a>Part 1 生日悖论:</h2><blockquote>
<p>如果一个班级有23个人, 那么其中有两个人生日相同的概率超过50%</p>
</blockquote>
<p>surprise 这与大部分人的直觉相违背, 所以称之为生日悖论</p>
<p>为什么会这样呢, 是自己的直觉不靠谱吗?</p>
<p>不, 我们可以考虑另一个问题, 如果一个班里有23人包括自己, 有人生日和自己相同的概率是多少?</p>
<p>没错, 大概为$6%$左右, 这是与直觉近似的, 其实我们的直觉正是把”有人生日相同”和”有人生日和自己相同”的概念相混, 实际有人生日和自己相同的概率确实很小</p>
<p>证明可以用排列组合开心的手玩一下</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质:"></a>性质:</h3><p>样本容量为$n$, 超过$50%$概率有两个样本相同的概率为</p>
<script type="math/tex; mode=display">
1.18\sqrt{n}</script><h2 id="Part-2-卡大质数hash-1000000009"><a href="#Part-2-卡大质数hash-1000000009" class="headerlink" title="Part 2 卡大质数hash (1000000009) :"></a>Part 2 卡大质数hash (1000000009) :</h2><p>考虑生日攻击, 随机一个1e5大小的字符串, 询问长度为$L$的本质不同子串有多少个, 用大质数$hash$和后缀数组(也可以用自然溢出$hash$)对拍, 输出不同子串的终止位置, 拿$fc$命令对比一下, 找出$hash$值相等的不同子串</p>
<p>正确性如生日悖论, 大概有超过$50%$的几率成功, 实际上质数不强的时候有很多相同</p>
<h2 id="Part-3-卡自然溢出hash"><a href="#Part-3-卡自然溢出hash" class="headerlink" title="Part 3 卡自然溢出hash:"></a>Part 3 卡自然溢出hash:</h2><p>自然溢出$hash$在数据随机的情况下正确性极高, 因为它的值域很大, 很难生日攻击</p>
<p>考虑特殊构造:</p>
<h3 id="对于底数为偶数"><a href="#对于底数为偶数" class="headerlink" title="对于底数为偶数:"></a>对于底数为偶数:</h3><p>构造$aaaa\cdots aaaa$ 和 $baaa\cdots aaaa$两个长度相等且长度大于64的串</p>
<p>底数的六十四次方以上模$P$就会为零, $b$和$a$也会被判为相等</p>
<h3 id="对于底数为奇数"><a href="#对于底数为奇数" class="headerlink" title="对于底数为奇数:"></a>对于底数为奇数:</h3><p>不太好卡, 要用神仙的构造方法:</p>
<p>设一个串$s[]$, $s[1] = ‘a’$ 设$ |s| = strlen(s + 1)$ 为$s$的长度 </p>
<p>定义$ (!s)$ 为$s$中的字符全部$’a’变’b’, ‘b’变’a’,$ 当然$s$中只含有$’a’$和$’b’$两种字符</p>
<p>定义串$S1 + S2$为$S1$串在前$S2$串在后拼接起来, $hash(s1)$ 为$s1$的哈希值</p>
<p>类似数列的, 我们定义一个”字符串列”, 为一个字符串集合{$S_n$}, 后一个字符串可以通过前一个字符串推出</p>
<p>$S_1 = “a”$</p>
<script type="math/tex; mode=display">
S_i = S_{i-1} + (!S_{i-1})</script><p>则$S_i$的长度为$2^{i-1}$</p>
<script type="math/tex; mode=display">
hash(S_i) = hash(S_{i-1}) * base^{|S_{i-1}|} + hash((!S_{i-1})) \\
= hash(S_{i-1}) * base^{2^{i-2}} + hash((!S_{i-1})) \\
hash((!S_{i-1})) = hash((!S_{i-2})) * base^{2^{i-2}} + hash(S_{i-1}) \\

hash(S_i) - hash((!S_{i-1})) = (hash(S_{i-1}) - hash((!S_{i-2}))) * base^{2^{i-2}} - (hash(S_{i-1}) - hash((!S_{i-2})))\\

hash(S_i) - hash((!S_{i-1})) = (hash(S_{i-1}) - hash((!S_{i-2}))) * (base^{2^{i-2}} - 1)</script><p>希望得到 $2^{64} | hash(S_i) - hash(!S_i)$ 设$g_i = hash(S_i) - hash(!S_i)$</p>
<p>$g_i=g_{i-1}*(base^{2^{i-2}}-1)$ 每个 $(base^{2^{i-2}}-1)$ 都是偶数, 这使得g到第64项就就可以卡掉hash了,</p>
<p>但事实上12位以上就行, 因为</p>
<script type="math/tex; mode=display">
base^{2^{i-1}}-1=(base^{2^{i-2}}-1)*(base^{2^{i-2}}+1)</script><p>为一个偶数乘一个偶数, 而左边的可以继续递归下去, 所以原式整除$2^i$ 然后就结束啦</p>
<blockquote>
<p>长大后, 我要当毒瘤, 爷爷奶奶可高兴了, 给我爱吃的…</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>字符串</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>毒瘤养成记</tag>
      </tags>
  </entry>
  <entry>
    <title>用极大化思想解决矩形问题学习笔记</title>
    <url>/2019/12/29/%E7%94%A8%E6%9E%81%E5%A4%A7%E5%8C%96%E6%80%9D%E6%83%B3%E8%A7%A3%E5%86%B3%E7%9F%A9%E5%BD%A2%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="用极大化思想解决矩形问题学习笔记"><a href="#用极大化思想解决矩形问题学习笔记" class="headerlink" title="用极大化思想解决矩形问题学习笔记"></a>用极大化思想解决矩形问题学习笔记</h1><ul>
<li><h2 id="问题引入："><a href="#问题引入：" class="headerlink" title="问题引入："></a>问题引入：</h2></li>
</ul>
<blockquote>
<p><strong>Winter Camp2002,奶牛浴场</strong></p>
<p><strong>题意简述</strong>：</p>
<p>John要在矩形牛场中建造一个大型浴场，但是这个大型浴场不能包含任何一个奶牛的产奶点，但产奶点可以出在浴场的边界上。John的牛场和规划的浴场都是矩形，浴场要完全位于牛场之内，并且浴场的轮廓要与牛场的轮廓平行或者重合。要求所求浴场的面积尽可能大。</p>
<p>参数约定：产奶点的个数S不超过5000,牛场的范围N×M不超过30000×30000。</p>
<p>输入：  </p>
<p>10 10<br>4<br>1 1<br>9 1<br>1 9<br>9 9</p>
<p>输出：</p>
<p>80</p>
</blockquote>
<a id="more"></a>
<ul>
<li><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2></li>
</ul>
<p><strong>有效子矩形：</strong> 内部（不包含边界）没有障碍点的子矩形（四边均与坐标轴平行）</p>
<p><strong>极大有效子矩形</strong>：不被任何一个有效子矩形包含（除本身）</p>
<p><strong>最大有效子矩形</strong>：最大的有效子矩形</p>
<ul>
<li><h3 id="小性质-："><a href="#小性质-：" class="headerlink" title="小性质 ："></a>小性质 ：</h3></li>
</ul>
<h3 id="1-极大有效子矩形的四条边无法向四边拓展，-也就是说四条边都存在障碍点或与大矩形边界重合"><a href="#1-极大有效子矩形的四条边无法向四边拓展，-也就是说四条边都存在障碍点或与大矩形边界重合" class="headerlink" title="1. 极大有效子矩形的四条边无法向四边拓展， 也就是说四条边都存在障碍点或与大矩形边界重合"></a>1. 极大有效子矩形的四条边无法向四边拓展， 也就是说四条边都存在障碍点或与大矩形边界重合</h3><h3 id="2-存在一个障碍点的矩形中最大有效子矩形一定是极大有效子矩形"><a href="#2-存在一个障碍点的矩形中最大有效子矩形一定是极大有效子矩形" class="headerlink" title="2.存在一个障碍点的矩形中最大有效子矩形一定是极大有效子矩形"></a>2.存在一个障碍点的矩形中最大有效子矩形一定是极大有效子矩形</h3><ul>
<li>【证明】：若最大有效子矩形不是极大有效子矩形，那么一定存在一个有效子矩形包括它，这与它的最大性相违背</li>
</ul>
<ul>
<li><h2 id="解决问题："><a href="#解决问题：" class="headerlink" title="解决问题："></a>解决问题：</h2></li>
</ul>
<p>1.思想一：枚举所有的极大有效子矩形</p>
<p>2.思想二：垂线法（后文介绍）</p>
<h2 id="算法一-O-s-2-："><a href="#算法一-O-s-2-：" class="headerlink" title="算法一  O($s^2$)："></a>算法一  O($s^2$)：</h2><p>由思想一我们可以得知，我们要枚举极大有效子矩形，尽量不枚举无效的，不是极大的子矩形</p>
<p>而由性质一得知，极大子矩形边界中必含障碍点</p>
<p>所以我们将所有障碍点按横坐标排序， 枚举障碍点所在纵线（与y轴平行的线）为极大有效子矩形的左边界（关于左边界是矩形边界下文讨论），再从左到右的扫描障碍点，更新答案后再更新上下边界</p>
<ul>
<li><p>更新答案：ans = max ( (上边界 - 下边界）* 横坐标之差 ， ans）</p>
</li>
<li><p>边界初始化：up = 0， down = 矩形纵长</p>
</li>
<li><p>更新边界： 如果新点在左边界点的上方，up = min(up,  其纵坐标)；否则 down = max（down， 其纵坐标）；</p>
</li>
<li><h3 id="bug-amp-改bug-："><a href="#bug-amp-改bug-：" class="headerlink" title="bug &amp; 改bug ："></a>bug &amp; 改bug ：</h3></li>
</ul>
<p>bug在于枚举过程中忽略了两类情况，一种是左边界在矩形左边界或右边界在矩形右边界的极大有效子矩形，另一种是左右边界都在矩形边界上（王知昆大佬的分类）。解决方法：将大矩形的四个顶点加入点集，然后横坐标排序跑一遍，纵坐标排序再跑一遍。横坐标跑的时候可以解决右边界问题，纵坐标跑时可以解决剩下问题（就像跑横坐标时可以解决上边界与下边界问题一样）</p>
<p>最后贴一下代码：</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> L, W;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(node i,node j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i.x &lt; j.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(node i,node j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i.y &lt; j.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; L &gt;&gt; W &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">	a[n+<span class="number">1</span>].y = a[n+<span class="number">1</span>].x = a[n+<span class="number">2</span>].x = a[n+<span class="number">3</span>].y = <span class="number">0</span>;</span><br><span class="line">	a[n+<span class="number">2</span>].y = a[n+<span class="number">4</span>].y = W;</span><br><span class="line">	a[n+<span class="number">3</span>].x = a[n+<span class="number">4</span>].x = L;</span><br><span class="line">	n += <span class="number">4</span>; <span class="comment">//加入矩形的四个顶点</span></span><br><span class="line">	sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp1);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>, up, down, v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		up = <span class="number">0</span>, down = W, v = L - a[i].x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v * (down - up) &lt;= ans) <span class="keyword">break</span>; <span class="comment">//剪枝</span></span><br><span class="line">			ans = <span class="built_in">max</span>(ans, (down - up) * (a[j].x - a[i].x));</span><br><span class="line">			<span class="keyword">if</span> (a[j].y &gt;= a[i].y) down = <span class="built_in">min</span>(down, a[j].y);</span><br><span class="line">			<span class="keyword">else</span> up = <span class="built_in">max</span>(up, a[j].y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp2);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		l = <span class="number">0</span>, r = L, v = W - a[i].y;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v * (r - l) &lt;= ans) <span class="keyword">break</span>;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, (r - l) * (a[j].y - a[i].y));</span><br><span class="line">			<span class="keyword">if</span> (a[j].x &gt;= a[i].x) r = <span class="built_in">min</span>(r, a[j].x);</span><br><span class="line">			<span class="keyword">else</span> l = <span class="built_in">max</span>(l, a[j].x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>


<h3 id="缺陷：可拓展性不够（后文例题介绍），在点（最多N-M）密集的情况下表现较差"><a href="#缺陷：可拓展性不够（后文例题介绍），在点（最多N-M）密集的情况下表现较差" class="headerlink" title="缺陷：可拓展性不够（后文例题介绍），在点（最多N * M）密集的情况下表现较差"></a>缺陷：可拓展性不够（后文例题介绍），在点（最多N * M）密集的情况下表现较差</h3><h2 id="算法二-O-N-M"><a href="#算法二-O-N-M" class="headerlink" title="算法二 O(N*M):"></a>算法二 O(N*M):</h2><p>前一种算法在许多点横坐标都相同时会做许多无用功，解决这个问题需要新的思路。通过极大有效矩形的定义得知，它的个数不会超过NM，所以我们决心寻找一种N*M级别的算法。</p>
<ul>
<li><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3></li>
</ul>
<p><strong>有效竖线</strong>：除了两个端点，不包含任何障碍点的线段</p>
<p><strong>悬线</strong>：上端点是障碍点或在矩形边界上的有效竖线</p>
<p>对于一个极大有效子矩形中，一定至少含有一条悬线，所以我们可以利用悬线来拓展形成极大有效子矩形</p>
<p>如果一条悬线尽可能的向两端扩张，直到碰到障碍点或矩形边界，则将此矩形面积更新ans，最终ans一定是最大有效子矩形面积</p>
<p>以每个格子为下端点的悬线有且仅有一条（除顶层格子），故悬线个数(n-1)*m。我们需要O(1)的查询每条悬线所对应的矩形；预处理出每个点向左到达的最远点，向右到达的最远点（向左和右扩张的宽度），向上到达的最远点（悬线的长度）</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//洛谷P4147</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[N][N], l[N][N], r[N][N], h[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">6</span>];</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'R'</span>) <span class="built_in">map</span>[i][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; j++) </span><br><span class="line">        h[i][j] = <span class="number">1</span>;</span><br><span class="line">        l[i][<span class="number">1</span>] = <span class="number">1</span>; r[i][m] = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= m; j++) </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>[i][j<span class="number">-1</span>]) l[i][j] = j;</span><br><span class="line">        <span class="keyword">else</span> l[i][j] = l[i][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>;j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>[i][j+<span class="number">1</span>]) r[i][j] = j;</span><br><span class="line">        <span class="keyword">else</span> r[i][j] = r[i][j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, r[i][j] - l[i][j] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">map</span>[i<span class="number">-1</span>][j]) &#123;</span><br><span class="line">                    h[i][j] = h[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    l[i][j] = <span class="built_in">max</span>(l[i][j], l[i<span class="number">-1</span>][j]);</span><br><span class="line">                    r[i][j] = <span class="built_in">min</span>(r[i][j], r[i<span class="number">-1</span>][j]);</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, (r[i][j] - l[i][j] + <span class="number">1</span>) * h[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> * ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>



<hr>
]]></content>
      <categories>
        <category>其他算法</category>
      </categories>
      <tags>
        <tag>悬线法</tag>
      </tags>
  </entry>
  <entry>
    <title>小结论</title>
    <url>/2019/12/29/%E5%B0%8F%E7%BB%93%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="小结论"><a href="#小结论" class="headerlink" title="小结论"></a>小结论</h1><h2 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关:"></a>数学相关:</h2><ul>
<li>$\displaystyle\sum_{k=1}^n \frac{1}{k} = lnk$</li>
<li>$C_n^m = C^{m-1}_{n-1} +C^m_{n-1}$</li>
<li>$C^m_n = \frac{n}{m} * C^{m-1}_{n-1}$</li>
<li>$C^0_n + C^1_n +  \cdots + C^n_n = 2^n$</li>
<li>$C_n^k$ k为奇数相加等于k为偶数相加</li>
<li>n/x下取整的可能值最多有根号n个</li>
<li>1~N内质数个数大概为$\frac{N}{lnN}$</li>
<li>对于大模数, 可以用小模数得出结果再用中国剩余定理还原</li>
<li>若(a, b) = 1,  则(a + k * b, b) = 1</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h2><ul>
<li>答案要求两数相等时, dp时可以维护两数的差而不是两数分别是什么</li>
</ul>
<a id="more"></a>
<h2 id="图论trick"><a href="#图论trick" class="headerlink" title="图论trick:"></a>图论trick:</h2><ul>
<li><h3 id="关于三点两两求lca"><a href="#关于三点两两求lca" class="headerlink" title="关于三点两两求lca"></a>关于三点两两求lca</h3><ul>
<li>其中有两个lca相同(求另一个可以三个一起异或起来)</li>
<li>不同的也是深度最大的那个</li>
<li>不同lca的三点在树上的分叉点</li>
<li>换根lca就是分叉点</li>
</ul>
</li>
<li><h3 id="关于源点和汇点"><a href="#关于源点和汇点" class="headerlink" title="关于源点和汇点"></a>关于源点和汇点</h3><ul>
<li>求一些点到另一些点的最短路可以建超级源点和汇点</li>
<li>一些点向另一些点连边可以新建源点和汇点</li>
</ul>
</li>
<li><p>分层图可以解决特殊边的问题,  可以通过dp减少空间</p>
</li>
<li><p>最大/小值多想想生成树</p>
</li>
</ul>
<h2 id="人类智慧"><a href="#人类智慧" class="headerlink" title="人类智慧:"></a>人类智慧:</h2><ul>
<li>将点不断分成两个集合, 使每两点至少有一次在不同的集合, 可以根据某一位在二进制上是否为一</li>
</ul>
<h2 id="基础算法与奇技淫巧"><a href="#基础算法与奇技淫巧" class="headerlink" title="基础算法与奇技淫巧:"></a>基础算法与奇技淫巧:</h2><ul>
<li><p>二分大于k的值设为一</p>
</li>
<li><p>无法直接dp可以试试先贪心排序</p>
</li>
<li><p>区间操作没准可以变成差分</p>
</li>
<li><p>闲的没事可以试试倒序操作</p>
</li>
<li><p>最大值最小, 最小值最大试试二分</p>
</li>
<li><p>实在想不出来学会面向数据编程, 小数据暴力, 大数据瞎搞</p>
</li>
<li><p>将数据分块, 大范围暴力, 小范围存储</p>
</li>
<li><p>逆序问题可以先进行排序</p>
</li>
<li><p>整体求值可以化为每个部分对答案的贡献, 在加上数据结构或重新化为另一个整体</p>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h2><ul>
<li>主元, 让你的式子的变量逐渐有某种规律(靠人类智慧</li>
<li>转化, 将一个问题转化为另一个已知问题(可能有多步转化</li>
<li>放弃, 适时的放弃能让你拿到更多的分数</li>
</ul>
<h2 id="心态和考场trick"><a href="#心态和考场trick" class="headerlink" title="心态和考场trick:"></a>心态和考场trick:</h2><ul>
<li>心态, 我会大家会, 我不会大家也会, 我会不会大家都会, 无所谓(滑稽</li>
<li>浏览一遍题目, 看看自己最少能拿多少分, 掌握最佳的分配时间</li>
<li>尝试hack自己, 用边界条件和细节问题</li>
<li>留出一个小时左右打对拍, 检查是否mle或没开够</li>
<li>做不出题时感觉题目很奇怪多半是题看错了</li>
<li>别的选手使劲敲键盘, 那就跟着敲几下, 吓唬一下别人(滑稽</li>
<li>想出题赶紧写, 调过样例, 去个厕所, 想不出来, 去个厕所, ak稳了, 去个厕所(滑稽</li>
<li>尽量吃熟悉的食物</li>
<li>检查时再读一遍题, 看看有没有输出”IMPOSSIBLE”啥的</li>
<li>尽管爆零, 走出考场时要大喊”我 AK 了”, 不留遗憾, 涨涨人品(滑稽</li>
<li>to be continued</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数学习笔记</title>
    <url>/2019/12/29/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="线性代数学习笔记"><a href="#线性代数学习笔记" class="headerlink" title="线性代数学习笔记"></a>线性代数学习笔记</h1><h2 id="一：行列式"><a href="#一：行列式" class="headerlink" title="一：行列式"></a>一：行列式</h2><p>前置芝士： 序列逆序对个数 $\tau  (a_1a_2a_3 \cdots a_n)  \displaystyle \sum^{n}_{i}{a[i] &lt; a[j] ( i &gt; j)}$</p>
<p>性质1: 交换序列中相邻的两个数会改变原序列逆序对个数的奇偶性</p>
<p>性质2: 交换序列中不相邻的两个数也会改变原序列逆序对个数的奇偶性</p>
<p>​    证明:$ a_1…a_i…a_j…a_n  不断将a~i~与它右边的数字交换直至正好换到a_j 即a_1…a_ja_i…a_n 此时共交换了j - i 次$</p>
<p>再将$a_j$ 向左与相邻数字交换j - i - 1次到原来$a_i$所在位置 ,此时共交换2 * (j - i) - 1次,为奇数次,所以奇偶性改变</p>
<a id="more"></a>
<p><strong>行列式正式登场:</strong> 定义: $\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp;a_{1n} \\<br>a_{21} &amp; a_{22} &amp; \cdots &amp;a_{2n} \\<br>\vdots &amp; \vdots &amp; \ddots &amp;\vdots \\<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp;a_{nn} \\<br>\end{bmatrix}$  =  $(-1)^{\tau (a_{1j_1} a_{2j_2}\cdots a_{nj_n})}$$\displaystyle \Pi ^{n} _ {i = 1}a_{ij_i} (j_i$ 互不相同)</p>
<p>性质1: 行列互换, 行列式的值不变</p>
<p>性质2: 交换行列式的两行或两列,行列式的符号改变</p>
<ul>
<li>推论: 如果行列式有两行或两列完全相同, 那么此行列式的值为零</li>
</ul>
<p>性质3: 行列式的某一行所有元素乘以一个数k等于用数k乘以此行列式</p>
<ul>
<li>推论1: 行列式中某一行(列)的所有元素全部是零, 那么这个行列式的值是零</li>
<li>推论2: 行列式中某一行(列)所有元素的公因子可以提到此行列式外面</li>
<li>推论3: 行列式如果有两行(列)对应元素成比例,那么次行列式的值为零</li>
</ul>
<p>性质4: 若行列式的某一列(行)的元素都是两数之和 , 如:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
a_{11} & a_{12} & \cdots &a_{1i} + a^{'}_{1i} & \cdots &a_{1n} \\
a_{21} & a_{22} & \cdots &a_{2i} + a^{'}_{2i} & \cdots &a_{2n} \\
\vdots & \vdots & \vdots &\vdots & \ddots &\vdots \\
a_{n1} & a_{n2} & \cdots &a_{ni} + a^{'}_{ni} & \cdots &a_{nn} \\
\end{bmatrix}</script><p>则D等于下列两个行列式的和:</p>
<p>D = $\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp;a_{1i} &amp; \cdots &amp;a_{1n} \\<br>a_{21} &amp; a_{22} &amp; \cdots &amp;a_{2i}  &amp; \cdots &amp;a_{2n} \\<br>\vdots &amp; \vdots &amp; \vdots &amp;\vdots &amp; \ddots &amp;\vdots \\<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp;a_{ni}&amp; \cdots &amp;a_{nn} \\<br>\end{bmatrix}$ + $\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots  &amp;a^{‘}_{1i} &amp; \cdots &amp;a_{1n} \\<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a^{‘}_{2i} &amp; \cdots &amp;a_{2n} \\<br>\vdots &amp; \vdots &amp; \vdots &amp;\vdots &amp; \ddots &amp;\vdots \\<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp;a^{‘}_{ni} &amp; \cdots &amp;a_{nn} \\<br>\end{bmatrix}$ </p>
<p>性质5: 把行列式的某一行(列)的元素乘以同一个数后加到另一行(列)的对应元素上,行列式不变</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
a_{11} & a_{12} & \cdots &a_{1n} \\
a_{21} & a_{22} & \cdots &a_{2n} \\
\vdots & \vdots & \ddots &\vdots \\
a_{n1} & a_{n2} & \cdots &a_{nn} \\
\end{bmatrix}</script><h3 id="代数余子式"><a href="#代数余子式" class="headerlink" title="代数余子式:"></a>代数余子式:</h3><p> 在n阶行列式D中划去任意选定的k行、k列后，余下的元素按原来顺序组成的n-k阶行列式M，称为行列式D的k阶子式A的余子式</p>
<h2 id="Matrix-Tree定理"><a href="#Matrix-Tree定理" class="headerlink" title="Matrix-Tree定理:"></a>Matrix-Tree定理:</h2><h3 id="拉普拉斯矩阵-度数矩阵-邻接矩阵"><a href="#拉普拉斯矩阵-度数矩阵-邻接矩阵" class="headerlink" title="拉普拉斯矩阵: 度数矩阵-邻接矩阵"></a>拉普拉斯矩阵: 度数矩阵-邻接矩阵</h3><script type="math/tex; mode=display">
L_{i,j}=
\begin{cases}
\deg(v_i),  &\text{if $i=j$}\\[2ex]
-1, &\text{if $i\not=j$ and $v_i$ is adjacent to $v_j$}\\[2ex]
0, &\text{otherwise}
\end{cases}</script><p>求出它任意一个代数余子式的值即为它生成树的数量</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul>
<li><p>求边权和: 将邻接矩阵改为边权, 度数矩阵改为边权和</p>
</li>
<li><p>有向图的生成图计数: 度数矩阵改为入度, 邻接矩阵改为有向边的邻接矩阵, 以x为根的生成树形图为删掉x行x列的代数余子式的值</p>
</li>
<li><p>一张有向图G, 欧拉回路的数量为$t1(G) * \Pi_{i=1}^n(deg(i)-1)!$ t1表示以一为根的生成树的数量</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>数学</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流学习笔记</title>
    <url>/2019/12/29/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="网络流学习笔记"><a href="#网络流学习笔记" class="headerlink" title="网络流学习笔记"></a>网络流学习笔记</h1><h3 id="网络流资料"><a href="#网络流资料" class="headerlink" title="网络流资料"></a><a href="https://wenku.baidu.com/view/986baf00b52acfc789ebc9a9.html" target="_blank" rel="noopener">网络流资料</a></h3><a id="more"></a>
<h2 id="最大流dinic"><a href="#最大流dinic" class="headerlink" title="最大流dinic"></a>最大流dinic</h2><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> to[M], ne[M];</span><br><span class="line"><span class="keyword">int</span> w[M], h[N], tot = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">	ne[++tot] = h[x], h[x] = tot;</span><br><span class="line">	to[tot] = y, w[tot] = z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span> (f) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> maxflow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> depth[N], cur[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(depth, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(depth));</span><br><span class="line">	<span class="keyword">while</span> (q.size()) q.pop();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cur[i] = h[i];</span><br><span class="line">	depth[s] = <span class="number">0</span>; q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = to[i];</span><br><span class="line">			<span class="keyword">if</span> (depth[y] &gt; INF &amp;&amp; w[i]) &#123;</span><br><span class="line">				depth[y] = depth[x] + <span class="number">1</span>;</span><br><span class="line">				q.push(y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> depth[t] &lt;= INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!limit || now == t) <span class="keyword">return</span> limit;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = cur[now]; ~i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = to[i]; cur[now] = i;</span><br><span class="line">		<span class="keyword">if</span> (depth[y] != depth[now] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		f = dfs(y, min(limit, w[i]));</span><br><span class="line">		<span class="keyword">if</span> (!f) <span class="keyword">continue</span>; flow += f; limit -= f;</span><br><span class="line">		w[i] -= f, w[i ^ <span class="number">1</span>] += f;</span><br><span class="line">		<span class="keyword">if</span> (!limit) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n), read(m), read(s), read(t);</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y, z; read(x), read(y), read(z);</span><br><span class="line">		add(x, y, z); add(y, x, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (bfs()) maxflow += dfs(s, INF);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, maxflow);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>


<h2 id="费用流dinic"><a href="#费用流dinic" class="headerlink" title="费用流dinic"></a>费用流dinic</h2><p>注意: </p>
<ul>
<li>反向边费用为负</li>
<li>dfs时用v标记每个点有没有被标记</li>
</ul>
<details><summary>talk is cheap, show me the code</summary>
<p>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], to[M], ne[M];</span><br><span class="line"><span class="keyword">int</span> cost[M], w[M], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	ne[++tot] = h[x], h[x] = tot;</span><br><span class="line">	to[tot] = y, w[tot] = z, cost[tot] = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N], cur[N];</span><br><span class="line"><span class="keyword">int</span> v[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line">	q.push(s); dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">		v[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i; i = ne[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = to[i]; <span class="keyword">if</span> (!w[i]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (cost[i] + dis[x] &lt; dis[y]) &#123;</span><br><span class="line">				dis[y] = cost[i] + dis[x];</span><br><span class="line">				<span class="keyword">if</span> (!v[y]) &#123;</span><br><span class="line">					v[y] = <span class="number">1</span>;</span><br><span class="line">					q.push(y);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dis[t] &gt;= INF) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cur[i] = h[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lim &lt;= <span class="number">0</span> || x == t) <span class="keyword">return</span> lim;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>; v[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = to[i]; cur[x] = i;</span><br><span class="line">		<span class="keyword">if</span> (v[y] || dis[y] != dis[x] + cost[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> f = dfs(y, min(lim, w[i]));</span><br><span class="line">		w[i] -= f, w[i^<span class="number">1</span>] += f;</span><br><span class="line">		res += f, lim -= f;</span><br><span class="line">		<span class="keyword">if</span> (lim &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans1, ans2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"hs.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	n = read(), m = read(), s = read(), t = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(), y = read(), z = read(), k = read();</span><br><span class="line">		add(x, y, z, k);</span><br><span class="line">		add(y, x, <span class="number">0</span>, -k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (spfa()) &#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = dfs(s, INF);</span><br><span class="line">		ans1 += tmp, ans2 += tmp * dis[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans1 &lt;&lt; <span class="string">' '</span> &lt;&lt; ans2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>

<h2 id="无源汇有上下界可行流"><a href="#无源汇有上下界可行流" class="headerlink" title="无源汇有上下界可行流"></a><a href="https://loj.ac/problem/115" target="_blank" rel="noopener">无源汇有上下界可行流</a></h2><p>先让每条边流量设为最小值, 发现可能流入流出量并不平衡</p>
<p>但是没问题, 反手一个转化, 要将网络流图加一个附加网络流图, 每条边的流量为最大流量-最小流量</p>
<p>对于每一个点, 都有一个A[i]表示其流入流量与流出流量的差</p>
<p>若A[i] &gt; 0, 说明流多了, 要往外流, 附加流的流入量要小于流出量, 否则就是附加流的流入量要大与流出量</p>
<p>那么我们新建一个超级源点s和超级汇点t</p>
<p>如果A[i]&gt;0, 连一条从s到i的流量为A[i]的边, 否则连一条从i到t的流量为-A[i]的边</p>
<p>跑一遍最大流, 如果最大流等于s的出边流量之和, 那么满足题意, 每条边的流量加上原来的最小流量即为所求</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], ne[N], to[N];</span><br><span class="line"><span class="keyword">int</span> w[N], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">	ne[++tot] = h[x], h[x] = tot;</span><br><span class="line">	to[tot] = y, w[tot] = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span> (f) <span class="keyword">return</span> -x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], ans[N];</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="keyword">int</span> sum, s, t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> cur[<span class="number">405</span>], dep[<span class="number">405</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span>(dep));</span><br><span class="line">	q.push(s); dep[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i; i = ne[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = to[i]; <span class="keyword">if</span> (!w[i] || dep[y]) <span class="keyword">continue</span>;</span><br><span class="line">			dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">			q.push(y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dep[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">4</span>; i++) cur[i] = h[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == t) <span class="keyword">return</span> lim;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = to[i]; cur[x] = i;</span><br><span class="line">		<span class="keyword">if</span> (!w[i] || dep[x] + <span class="number">1</span> != dep[y]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> f = dfs(y, min(lim, w[i]));</span><br><span class="line">		w[i] -= f, w[i^<span class="number">1</span>] += f;</span><br><span class="line">		res += f, lim -= f;</span><br><span class="line">		<span class="keyword">if</span> (!lim) <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(), m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(), y = read(), l = read(), r = read();</span><br><span class="line">		ans[i] = l; a[y] += l, a[x] -= l;</span><br><span class="line">		add(x, y, r - l); add(y, x, <span class="number">0</span>);</span><br><span class="line">		num[i] = tot;</span><br><span class="line">	&#125;</span><br><span class="line">	s = n + <span class="number">1</span>, t = n + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			sum += a[i];</span><br><span class="line">			add(s, i, a[i]);</span><br><span class="line">			add(i, s, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			add(i, t, -a[i]);</span><br><span class="line">			add(t, i, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (bfs()) flow += dfs(s, INF);</span><br><span class="line">	<span class="keyword">if</span> (sum != flow) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans[i] + w[num[i]]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</p>
</details>



<h2 id="有源汇有上下界可行流-最大流-最小流"><a href="#有源汇有上下界可行流-最大流-最小流" class="headerlink" title="有源汇有上下界可行流 (最大流/最小流)"></a><a href="https://loj.ac/problem/117" target="_blank" rel="noopener">有源汇有上下界可行流 (最大流/最小流)</a></h2><p><strong>有汇源有上下界的可行流</strong></p>
<p>设S, T为超级源点和超级汇点, s, t 为源点和汇点</p>
<p>埋伏他一手, 首先把有汇源问题转化为无汇源问题, 闷声发大财</p>
<p>因为源点和汇点入流和出流不平衡, 从t向s连一条无穷大的边使它平衡, 然后在跑上一问题</p>
<p>设tmp  = t 到 s的边的流量, res1 = 拆掉无穷大的边从s到t所跑的最大流, res2 = 拆掉无穷大的边从t到s所跑的最大流</p>
<p><strong>最大流</strong>,  ans = tmp + res1</p>
<p>思路: 先找到一个可行流, 在残余网络中在跑一遍最大流, 使不能产生新流</p>
<p><strong>最小流</strong>,  ans = tmp - res2</p>
<p>思路: 先找到一个可行流, 从t到s取消流量, 即回退可行流中可以退的流.</p>
<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], ne[N], to[N];</span><br><span class="line"><span class="keyword">int</span> w[N], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">	ne[++tot] = h[x], h[x] = tot;</span><br><span class="line">	to[tot] = y, w[tot] = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span> (f) <span class="keyword">return</span> -x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="keyword">int</span> sum, ss, tt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> cur[<span class="number">405</span>], dep[<span class="number">405</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span>(dep));</span><br><span class="line">	q.push(s); dep[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i; i = ne[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = to[i]; <span class="keyword">if</span> (!w[i] || dep[y]) <span class="keyword">continue</span>;</span><br><span class="line">			dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">			q.push(y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dep[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">4</span>; i++) cur[i] = h[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lim,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == t) <span class="keyword">return</span> lim;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = to[i]; cur[x] = i;</span><br><span class="line">		<span class="keyword">if</span> (!w[i] || dep[x] + <span class="number">1</span> != dep[y]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> f = dfs(y, min(lim, w[i]), t);</span><br><span class="line">		w[i] -= f, w[i^<span class="number">1</span>] += f;</span><br><span class="line">		res += f, lim -= f;</span><br><span class="line">		<span class="keyword">if</span> (!lim) <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">int</span> ans, s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(), m = read(), ss = read(), tt = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(), y = read(), l = read(), r = read();</span><br><span class="line">		a[y] += l, a[x] -= l;</span><br><span class="line">		add(x, y, r - l); add(y, x, <span class="number">0</span>);</span><br><span class="line">		num[i] = tot;</span><br><span class="line">	&#125;</span><br><span class="line">	s = n + <span class="number">1</span>, t = n + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			sum += a[i];</span><br><span class="line">			add(s, i, a[i]);</span><br><span class="line">			add(i, s, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			add(i, t, -a[i]);</span><br><span class="line">			add(t, i, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	add(tt, ss, INF);</span><br><span class="line">	<span class="keyword">while</span> (bfs(s, t)) flow += dfs(s, INF, t);</span><br><span class="line">	<span class="keyword">if</span> (sum != flow) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"please go home to sleep\n"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	flow = w[tot^<span class="number">1</span>];</span><br><span class="line">	w[tot] = w[tot^<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (bfs(ss, tt)) &#123;</span><br><span class="line">		dep[n+<span class="number">1</span>] = dep[n+<span class="number">2</span>] = INF;</span><br><span class="line">		flow += dfs(ss, INF, tt);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; flow &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>



<h3 id="最小流"><a href="#最小流" class="headerlink" title="最小流"></a>最小流</h3><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">800005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], ne[N], to[N];</span><br><span class="line">ll w[N], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll z)</span> </span>&#123;</span><br><span class="line">	ne[++tot] = h[x], h[x] = tot;</span><br><span class="line">	to[tot] = y, w[tot] = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	ll x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span> (f) <span class="keyword">return</span> -x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll a[N];</span><br><span class="line">ll num[N];</span><br><span class="line">ll sum, ss, tt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">0x7fffffffffff</span>;</span><br><span class="line">ll cur[N], dep[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span>(dep));</span><br><span class="line">	q.push(s); dep[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i; i = ne[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = to[i]; <span class="keyword">if</span> (!w[i] || dep[y]) <span class="keyword">continue</span>;</span><br><span class="line">			dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">			q.push(y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dep[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n+<span class="number">4</span>; i++) cur[i] = h[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll flow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,ll lim,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == t) <span class="keyword">return</span> lim;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = to[i]; cur[x] = i;</span><br><span class="line">		<span class="keyword">if</span> (!w[i] || dep[x] + <span class="number">1</span> != dep[y]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> f = dfs(y, min(lim, w[i]), t);</span><br><span class="line">		w[i] -= f, w[i^<span class="number">1</span>] += f;</span><br><span class="line">		res += f, lim -= f;</span><br><span class="line">		<span class="keyword">if</span> (!lim) <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line">ll ans, s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(), m = read(), ss = read(), tt = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">		ll x = read(), y = read(), l = read(), r = read();</span><br><span class="line">		a[y] += l, a[x] -= l;</span><br><span class="line">		add(x, y, r - l); add(y, x, <span class="number">0</span>);</span><br><span class="line">		num[i] = tot;</span><br><span class="line">	&#125;</span><br><span class="line">	s = n + <span class="number">1</span>, t = n + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			sum += a[i];</span><br><span class="line">			add(s, i, a[i]);</span><br><span class="line">			add(i, s, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			add(i, t, -a[i]);</span><br><span class="line">			add(t, i, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	add(tt, ss, INF);</span><br><span class="line">	<span class="keyword">while</span> (bfs(s, t)) flow += dfs(s, INF, t);</span><br><span class="line">	<span class="keyword">if</span> (sum != flow) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"please go home to sleep\n"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	flow = w[tot^<span class="number">1</span>];</span><br><span class="line">	w[tot] = w[tot^<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (bfs(tt, ss)) &#123;</span><br><span class="line">		dep[n+<span class="number">1</span>] = dep[n+<span class="number">2</span>] = INF;</span><br><span class="line">		flow -= dfs(tt, INF, ss);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; flow &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</p>
</details>



<h2 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h2><p>一个有向图的闭合图是该有向图的一个点集, 且点集所有的出边所指向的点还在该点集</p>
<p>给每个点分配一个权值, 一个闭合图中点权和最大的叫做最大权闭合子图</p>
<p>由定义可知, 闭合图中可能包含不只一个连通块</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/o30e9nuv.png" alt=""></p>
<p>可以用网络流来解决, 首先建图</p>
<p>i的点权为w[i]</p>
<p>超级源点s向所有点权为正的点连一条边权为w[i]的边, 超级汇点t向所有点权为负的点连一条边权为-w[i]的边</p>
<p>对于原来有向图上的每条边(u, v), 在网络图上连一条容量为INF的边(u, v), 答案是正点权和减去最小割</p>
<p>最大闭合子图就是与超级源点在同一连通块的点集</p>
<h3 id="证明-proof"><a href="#证明-proof" class="headerlink" title="证明(proof)"></a>证明(proof)</h3><p>首先, 最小割割断的只能是与源点和汇点相连的边, 因为割断无穷大显然是不优的</p>
<p>性质: 闭合图和简单割互相对应</p>
<p>以下均为绝对值:</p>
<blockquote>
<p>S连接的割边分割后在T集边权为正的点的权值和S1<br>S连接的割边分割后在T集边权为负的点的权值和S2<br>T连接的割边分割后在S集边权为正的点的权值和T1<br>T连接的割边分割后在S集边权为负的点的权值和T2 </p>
</blockquote>
<p>所以最小割的权值为S1 + T2, 最大闭合子图权值为正权减去负权= T1 - T2</p>
<p>相加即为T1 + S1 = 正点权之和</p>
<p>得证</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul>
<li><a href="https://www.luogu.org/problem/P2762" target="_blank" rel="noopener">太空飞行计划问题</a></li>
<li><a href="https://www.luogu.org/problem/P4174" target="_blank" rel="noopener">[NOI2006]最大获利</a></li>
</ul>
<h2 id="最大密度子图"><a href="#最大密度子图" class="headerlink" title="最大密度子图"></a>最大密度子图</h2><p>定义: 一个无向图(V, E) 的密度g = $\frac{|E|}{|V|}$</p>
<p>最大密度子图即最大化无向图的密度</p>
<p>考虑<strong>分数规划</strong>, 二分g的值</p>
<p>设计函数$H(x) = max \{\sum_{a\in E}1 - \sum_{b \in V}x\}$ 若H(g) &gt; 0 说明密度大于g, else 密度小于等于g</p>
<p>可以证明二分的范围是 $\frac{|E|}{|V|}$ 到 m, 精度是$\frac{1}{n^2}$</p>
<p>反手一步转化, 每条边(u, v)的存在条件是u和v已经存在, 所以考虑<strong>最大闭合子图</strong>, 8将边化为权值为1的点, 分别向u, v连一条边权为INF的边, 点权为-g, 用上一方法即可</p>
<p>复杂度 $\Theta(log_nmaxflow(n+m,n+m))$</p>
<p>此算法还可以继续改进为$\Theta(log_nmaxflow(n,n+m))$, 详见文头资料</p>
<p>拓展: 带点权和边权也可以哦</p>
<h2 id="二分图的最小点权覆盖集和最大点权独立集"><a href="#二分图的最小点权覆盖集和最大点权独立集" class="headerlink" title="二分图的最小点权覆盖集和最大点权独立集"></a>二分图的最小点权覆盖集和最大点权独立集</h2><p>覆盖集: 所有边至少一个端点在覆盖集中</p>
<p>独立集: 一坨点两两之间没有连边</p>
<p>对于边(u, v) 连一条INF边, s向左部点连边权为点权的边, 右部点向t连边权为点权的边</p>
<p>对于一条简单路径s -&gt; u -&gt; v -&gt; t, 至少要割断一条边</p>
<p>u - &gt; v是不可能被割断的, 被割断的一定是s -&gt; u, v -&gt; t, 代表u, v中最多选一个, 删其边代表不选他, 那么最大点权独立集为点权和-最小割, 最小割对应最小点权覆盖集</p>
<h2 id="网络流24题中的思想与解题方案"><a href="#网络流24题中的思想与解题方案" class="headerlink" title="网络流24题中的思想与解题方案"></a>网络流24题中的思想与解题方案</h2><ul>
<li><p>拆点思想: 一个物品/时间拆成两个点, 两点之间连边表示此物品的使用次数, 费用</p>
</li>
<li><p>分层图思想: 按时间(或其他)分层, 每次新建一个单位时间的图, 在残余网络上跑dinic</p>
</li>
<li><p>转化思想: 将问题转化为模型(最小点权覆盖集, 最大点权独立集, 最大权闭合子图)</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>图论</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>图的计数</title>
    <url>/2019/12/29/%E5%9B%BE%E7%9A%84%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p><strong>形式：求n个点____ 的个数</strong><br><a id="more"></a></p>
<h2 id="有标号无向图的个数（不一定联通）：-2-C-n-2"><a href="#有标号无向图的个数（不一定联通）：-2-C-n-2" class="headerlink" title="有标号无向图的个数（不一定联通）：$2^{C_n^2}$"></a>有标号无向图的个数（不一定联通）：<strong>$2^{C_n^2}$</strong></h2><p>证明显然</p>
<h2 id="有标号无向联通图个数："><a href="#有标号无向联通图个数：" class="headerlink" title="有标号无向联通图个数："></a>有标号无向联通图个数：</h2><p>设g(x)为不一定联通图的个数， f(x) 为连通图个数</p>
<p>枚举1号点所在联通块的大小</p>
<p>$g(x) = \displaystyle \sum_{i=1}^{n}{n - 1 \choose i - 1}f(i) * g(n - i)$</p>
<p>最后将$g(x) = 2^{C_n^2}$带进去即可<br>（多项式我不会。。。）</p>
<h2 id="所有点度数都是偶数的有标号图（不一定联通）-：-2-C-n-1-2"><a href="#所有点度数都是偶数的有标号图（不一定联通）-：-2-C-n-1-2" class="headerlink" title="所有点度数都是偶数的有标号图（不一定联通） ： $2^{C_{n-1}^2}$"></a>所有点度数都是偶数的有标号图（不一定联通） ： <strong>$2^{C_{n-1}^2}$</strong></h2><p>可以将1-n-1的点任意连起来</p>
<p>可以证明一个图中度数为奇数的点有偶数个</p>
<p>那么将点n将1-n-1度数为奇的点连起来</p>
<p>所有的点度数都将成为偶数</p>
<h2 id="所有点度数都是偶数的有标号图（联通）-："><a href="#所有点度数都是偶数的有标号图（联通）-：" class="headerlink" title="所有点度数都是偶数的有标号图（联通） ："></a>所有点度数都是偶数的有标号图（联通） ：</h2><p>类似的</p>
<p>设g(x)为不一定联通图的个数， f(x) 为连通图个数</p>
<p>枚举1号点所在联通块的大小</p>
<p>$g(x) = \displaystyle \sum_{i=1}^{n}{n - 1 \choose i - 1}f(i) * g(n - i)$</p>
<p>$f(x) = g(x) - \displaystyle \sum_{i=1}^{n-1}{n - 1 \choose i - 1}f(i) * g(n - i)$</p>
<h2 id="无标号有根树：-n-n-2"><a href="#无标号有根树：-n-n-2" class="headerlink" title="无标号有根树：$ n ^ {n-2}$"></a>无标号有根树：$ n ^ {n-2}$</h2><p>也可以说n个点完全图生成树的个数</p>
<p><strong>引理： prufer序列</strong></p>
<p>prufer是一种无根树的编码表示， 对于一棵n节点无根树，唯一对应一个长度为n-2的序列</p>
<p>理解：prufer将树的n-2个父亲节点（可重复）加上神奇的构造方式表示每个父亲的儿子， 即表示了每条边；</p>
<p><strong>（1） 无根树转prufer序列</strong></p>
<p>操作：每次取叶子节点（度数为1）中标号最小的一个，将它的父亲节点加入序列， 并将其删除 </p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ta4fyv68.png" alt="网上盗的图"> </p>
<p>如图的序列为： 3 5 1 3</p>
<p>用set实现</p>
<p>有一个性质： 某个编号出现的次数等于这个节点在无根树中的度数</p>
<p><strong>（2）prufer序列转无根树</strong></p>
<p>设节点集合v={1,2,3…n}, prufer序列集合A={$a_1,a_2…,a_{n-2}$}</p>
<p>每次取出prufer序列最前面的编号u， 找到v中最小的且未在A中的点v，<br>将u，v连边， 在两个集合中分别删去它们；<br>依然用set搞定</p>
<h4 id="由此说明任意一个n-2序列都可得到一棵不同的无根树"><a href="#由此说明任意一个n-2序列都可得到一棵不同的无根树" class="headerlink" title="由此说明任意一个n-2序列都可得到一棵不同的无根树"></a>由此说明任意一个n-2序列都可得到一棵不同的无根树</h4><p><strong>无根树的个数为：$ n ^ {n-2}$</strong></p>
<p> <strong>一个有趣的推广是，n个节点的度依次为D1, D2, …, Dn的无根树共有(n-2)! / [ (D1-1)!(D2-1)!..(Dn-1)! ]个，因为此时Prüfer编码中的数字i恰好出现Di-1次。</strong></p>
<h2 id="有标号有根树：-n-n-1"><a href="#有标号有根树：-n-n-1" class="headerlink" title="有标号有根树： $ n ^ {n-1}$"></a>有标号有根树： $ n ^ {n-1}$</h2><p>即每棵无根树的每个节点都可以当根， 再乘上n即可</p>
<p><a href="https://www.cnblogs.com/flashhu/p/9457830.html" target="_blank" rel="noopener">学习ing</a></p>
<hr>
]]></content>
      <categories>
        <category>数学</category>
        <category>计数</category>
      </categories>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>数论板子</title>
    <url>/2019/12/29/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="数论板子"><a href="#数论板子" class="headerlink" title="数论板子"></a>数论板子</h1><h3 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块 :"></a>数论分块 :</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">j = n / (n / i);</span><br><span class="line">ans += (n/i) * (j - i + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法:"></a>筛法:</h2><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛:"></a>线性筛:</h3><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">bool</span> prime[MAXN];</span><br><span class="line"><span class="keyword">int</span> Prime[MAXN];</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(prime));</span><br><span class="line">    prime[<span class="number">0</span>]=prime[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAXN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            Prime[num++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num&amp;&amp;i*Prime[j]&lt;MAXN;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            prime[i*Prime[j]]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%Prime[j]))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>


<h3 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛:"></a>杜教筛:</h3><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::tr1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">7000005</span>;</span><br><span class="line">ll sum_phi[N];</span><br><span class="line"><span class="keyword">int</span> sum_mu[N];</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">2000005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> maxn = <span class="number">7000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	sum_phi[<span class="number">1</span>] = sum_mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= maxn; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">			prime[++tot] = i;</span><br><span class="line">			sum_phi[i] = i - <span class="number">1</span>;</span><br><span class="line">			sum_mu[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= tot &amp;&amp; prime[j] * i &lt;= maxn; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = i * prime[j];</span><br><span class="line">			vis[tmp] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % prime[j]) &#123;</span><br><span class="line">				sum_phi[tmp] = sum_phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">				sum_mu[tmp] = -sum_mu[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				sum_phi[tmp] = sum_phi[i] * prime[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= maxn; i++) </span><br><span class="line">	sum_phi[i] += sum_phi[i<span class="number">-1</span>], </span><br><span class="line">	sum_mu[i] += sum_mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,ll&gt; f_mu, f_phi;</span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= maxn) <span class="keyword">return</span> sum_phi[x];</span><br><span class="line">	<span class="keyword">if</span> (f_phi[x]) <span class="keyword">return</span> f_phi[x];</span><br><span class="line">	ll ans = (<span class="number">1</span> + (ll)x) * (ll)x / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r;l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        p = x / l;</span><br><span class="line">		r = x / p;</span><br><span class="line">		ans -= (r - l + <span class="number">1</span>) * phi(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f_phi[x] = ans;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= maxn) <span class="keyword">return</span> sum_mu[x];</span><br><span class="line">	<span class="keyword">if</span> (f_mu[x]) <span class="keyword">return</span> f_mu[x];</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r;l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">		r = x / (p = x / l);</span><br><span class="line">		ans -= (r - l + <span class="number">1</span>) * mu(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f_mu[x] = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	pre();</span><br><span class="line">	T = read();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		n = read();</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"%lld %d\n"</span>, phi(n), mu(n));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>


<h3 id="拓展欧几里得"><a href="#拓展欧几里得" class="headerlink" title="拓展欧几里得:"></a>拓展欧几里得:</h3><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> x, y, a, b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = m / n, p = m % n;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">1</span>) &#123;</span><br><span class="line">		x = -k, y = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	gcd(n, p);</span><br><span class="line">	<span class="keyword">int</span> z = y;</span><br><span class="line">	y = x,x = z - x * k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">	gcd(a, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (y % b + b) % b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 乘法逆元(线性) :

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3006000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll inv[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, p; <span class="built_in">cin</span> &gt;&gt; n; <span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">	inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		inv[i] = (p - (p / i)) * inv[p % i] % p;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, inv[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>



<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂(???) :"></a>快速幂(???) :</h3><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,k;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fuc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> h=fuc(b/<span class="number">2</span>)%k;</span><br><span class="line">	<span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> h*h;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> h*h*a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> b;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;k;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">"^"</span>&lt;&lt;b&lt;&lt;<span class="string">" mod "</span>&lt;&lt;k&lt;&lt;<span class="string">"="</span>&lt;&lt;fuc(b)%k;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>



<hr>
]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分板子</title>
    <url>/2019/12/29/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<a id="more"></a>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p1 p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p2 p &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100050</span>;</span><br><span class="line">ll sum[N&lt;&lt;<span class="number">3</span>], <span class="keyword">add_t</span>[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">l_t</span>[N&lt;&lt;<span class="number">3</span>], <span class="keyword">r_t</span>[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	ll x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> siz[N], top[N];</span><br><span class="line"><span class="keyword">int</span> f[N], dep[N], son[N];</span><br><span class="line"><span class="keyword">int</span> h[N], to[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ne[N&lt;&lt;<span class="number">1</span>], tot;</span><br><span class="line">ll w[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_e</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	ne[++tot] = h[x];</span><br><span class="line">	h[x] = tot;</span><br><span class="line">	to[tot] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	siz[x] = <span class="number">1</span>;</span><br><span class="line">	f[x] = fa;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = to[i];</span><br><span class="line">		<span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">		dfs1(y, x);</span><br><span class="line">		siz[x] += siz[y];</span><br><span class="line">		<span class="keyword">if</span> (siz[y] &gt; siz[son[x]]) son[x] = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll wt[N], cnt;</span><br><span class="line"><span class="keyword">int</span> id[N], Top[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">	id[x] = ++cnt;</span><br><span class="line">	wt[cnt] = w[x];</span><br><span class="line">	Top[x] = topf;</span><br><span class="line">	<span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">	dfs2(son[x], topf);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = to[i];</span><br><span class="line">		<span class="keyword">if</span> (y == f[x] || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(y, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, m, r, P;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buil</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">l_t</span>[p] = l, <span class="keyword">r_t</span>[p] = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		sum[p] = wt[l] % P;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	buil(l, mid, p1);</span><br><span class="line">	buil(mid + <span class="number">1</span>, r, p2);</span><br><span class="line">	sum[p] = sum[p1] + sum[p2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">add_t</span>[p]) &#123;</span><br><span class="line">		sum[p1] += (ll)(<span class="keyword">r_t</span>[p1] - <span class="keyword">l_t</span>[p1] + <span class="number">1</span>) * <span class="keyword">add_t</span>[p];</span><br><span class="line">		sum[p2] += (ll)(<span class="keyword">r_t</span>[p2] - <span class="keyword">l_t</span>[p2] + <span class="number">1</span>) * <span class="keyword">add_t</span>[p];</span><br><span class="line">		<span class="keyword">add_t</span>[p1] += <span class="keyword">add_t</span>[p];</span><br><span class="line">		<span class="keyword">add_t</span>[p2] += <span class="keyword">add_t</span>[p];</span><br><span class="line">		sum[p1] %= P;</span><br><span class="line">		sum[p2] %= P;</span><br><span class="line">		<span class="keyword">add_t</span>[p1] %= P;</span><br><span class="line">		<span class="keyword">add_t</span>[p2] %= P;</span><br><span class="line">		<span class="keyword">add_t</span>[p]= <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll d,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">l_t</span>[p] &gt;= l &amp;&amp; <span class="keyword">r_t</span>[p] &lt;= r) &#123;</span><br><span class="line">		sum[p] += (<span class="keyword">r_t</span>[p] - <span class="keyword">l_t</span>[p] + <span class="number">1</span>) * d;</span><br><span class="line">		sum[p] %= P;</span><br><span class="line">		<span class="keyword">add_t</span>[p] += d;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	spread(p);</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= <span class="keyword">r_t</span>[p1]) add(l, r, d, p1);</span><br><span class="line">	<span class="keyword">if</span> (r &gt;= <span class="keyword">l_t</span>[p2]) add(l, r, d, p2);</span><br><span class="line">	sum[p] = sum[p1] + sum[p2];</span><br><span class="line">	sum[p] %= P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">l_t</span>[p] &gt;= l &amp;&amp; <span class="keyword">r_t</span>[p] &lt;= r)</span><br><span class="line">		<span class="keyword">return</span> sum[p];</span><br><span class="line">	spread(p);</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">r_t</span>[p1] &gt;= l) ans += ask(l, r, p1);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">l_t</span>[p2] &lt;= r) ans += ask(l, r, p2);</span><br><span class="line">	<span class="keyword">return</span> ans % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (Top[x] != Top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[Top[x]] &lt; dep[Top[y]]) swap(x, y);</span><br><span class="line">		add(id[Top[x]], id[x], z, <span class="number">1</span>);</span><br><span class="line">		x = f[Top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">	add(id[y], id[x], z, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (Top[x] != Top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[Top[x]] &lt; dep[Top[y]]) swap(x, y);</span><br><span class="line">		ans += ask(id[Top[x]], id[x], <span class="number">1</span>);</span><br><span class="line">		x = f[Top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">	ans += ask(id[y], id[x], <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ans % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_w</span><span class="params">(<span class="keyword">int</span> x,ll z)</span> </span>&#123;</span><br><span class="line">	add(id[x], id[x] + siz[x] - <span class="number">1</span>, z, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query_w</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ask(id[x], id[x] + siz[x] - <span class="number">1</span>, <span class="number">1</span>) % P;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(), m = read(), r = read(), P = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) w[i] = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">		add_e(x, y); add_e(y, x);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs1(r, <span class="number">0</span>);</span><br><span class="line">	dfs2(r, r);</span><br><span class="line">	buil(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> op = read();</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">			ll z = read() % P;</span><br><span class="line">			update(x, y, z);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, query(x, y));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = read();</span><br><span class="line">			ll z = read();</span><br><span class="line">			add_w(x, z % P);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> x = read();</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, query_w(x));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>



<hr>
]]></content>
      <categories>
        <category>树上问题</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>群论笔记</title>
    <url>/2019/12/29/%E7%BE%A4%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<a id="more"></a>
<p>$\sum_{n \ge 0} x^n=\frac{1}{1-x}$</p>
<p>$\sum_{n \ge 1} x^n=\frac{x}{1-x}$?</p>
<p>$\sum_{n \ge 1} x^n=x*(\sum_{n \ge 0} x^n)$</p>
<p>$\sum_{n \ge 1} n x^n=$?</p>
<p>$(\sum_{n \ge 0} x^n)’=(\frac{1}{1-x})’$</p>
<p>$\sum_{n \ge 0} (n+1)x^n=\frac{1}{(1-x)^2}$</p>
<p>$\sum_{n \ge 0} (n+1)x^{n+1}=\frac{x}{(1-x)^2}$</p>
<p>$(\sum_{n \ge 0} x^n)*(\sum_{n \ge 0} x^n)=\sum_{n \ge 0} (n+1)x^n=\frac{1}{(1-x)^2}$</p>
<p>$\sum_{n \ge 0} \frac{1}{n!}x^n=e^x$</p>
<p>$f_0=f_1=1$</p>
<p>$f_0~f_1~f_2$</p>
<p>$~~~~f_0~f_1~f_2$</p>
<p>$<del>~</del>~~~~f_0~f_1~f_2$</p>
<p>$(1~2 ~3)$</p>
<p>$\{e,(1~2~3),(1~3~2)\}$</p>
<p>$\sum_{g\in G} f(g)=\{(g,x) \in G \times X| g * x = x\}$</p>
<p>$=\sum_{x \in X} |G_x|$</p>
<p>$|G*x|=|G:G_x|=|G|/|G_x|$</p>
<p>$\sum_{x \in X} |G_x|=\sum _{x \in } \frac{|G|}{|G<em>x|}=|G|\sum_{x\in X}\frac{1}{|G</em>x|}$</p>
<p>$\sum_{x\in X}\frac{1}{|G*x|}=\sum_{A \in X/G} \sum_{x \in A} \frac{1}{|A|}=|X/G|$</p>
<p>$p(1)=2,p(2)=1,p(3)=4,p(4)=3$</p>
<p>$(1~2)(3~4)$</p>
<hr>
]]></content>
      <categories>
        <category>数学</category>
        <category>群论</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>学习笔记</tag>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序深入理解</title>
    <url>/2019/12/29/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="冒泡排序深入理解"><a href="#冒泡排序深入理解" class="headerlink" title="冒泡排序深入理解"></a>冒泡排序深入理解</h1><h3 id="对于冒泡排序有一个小性质-每一次都会把序列未排好序的最大数”沉底”-即推到序列尾部"><a href="#对于冒泡排序有一个小性质-每一次都会把序列未排好序的最大数”沉底”-即推到序列尾部" class="headerlink" title="对于冒泡排序有一个小性质: 每一次都会把序列未排好序的最大数”沉底”, 即推到序列尾部"></a>对于冒泡排序有一个小性质: 每一次都会把序列未排好序的最大数”沉底”, 即推到序列尾部</h3><h2 id="1-P4378-Out-of-Sorts-S"><a href="#1-P4378-Out-of-Sorts-S" class="headerlink" title="1.P4378 Out of Sorts S"></a>1.<a href="https://www.luogu.org/problem/P4378" target="_blank" rel="noopener">P4378 Out of Sorts S</a></h2><blockquote>
<p>留意着农场之外的长期职业生涯的可能性，奶牛Bessie开始在不同的在线编程网站上学习算法。</p>
<p>她到目前为止最喜欢的算法是“冒泡排序”。这是Bessie的对长度为<em>N</em>的数组<em>A</em>进行排序的奶牛码实现。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sorted &#x3D; false</span><br><span class="line">while (not sorted):</span><br><span class="line">   sorted &#x3D; true</span><br><span class="line">   moo</span><br><span class="line">   for i &#x3D; 0 to N-2:</span><br><span class="line">      if A[i+1] &lt; A[i]:</span><br><span class="line">         swap A[i], A[i+1]</span><br><span class="line">         sorted &#x3D; false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>显然，奶牛码中的“moo”指令的作用只是输出“moo”。奇怪的是，Bessie看上去执着于在她的代码中的不同位置使用这个语句。</p>
<p>给定一个输入数组，请预测Bessie的代码会输出多少次“moo”。</p>
</blockquote>
<p>题意即进行多少次冒泡排序</p>
<h3 id="对于一个序列-我们称之为有序的-当且仅当对于任意一个位置前面没有比它大的数-可以模拟一下"><a href="#对于一个序列-我们称之为有序的-当且仅当对于任意一个位置前面没有比它大的数-可以模拟一下" class="headerlink" title="对于一个序列, 我们称之为有序的, 当且仅当对于任意一个位置前面没有比它大的数(可以模拟一下)"></a>对于一个序列, 我们称之为有序的, 当且仅当对于任意一个位置前面没有比它大的数(可以模拟一下)</h3><p>比如:6 1 2 3 4 5 进行一次为 1 2 3 4 5 6</p>
<p>那么对于位置i, 冒泡排序进行到i-1时, $a_{i-1}$为前i1个数中最大的一个, 如果它大于$a_i$那么它就会到$a_i$的后面</p>
<p>由此可推知, 每一次位置i前都会将一个比$a_i$大的数推至其后, 直至没有比它大的</p>
<p>那么我们对每位置求一下它前面有几个比它大就好啦(注意要将答案加一)</p>
<p>具体来说先进行离散化, 再树状数组求解即可</p>
<details><summary>talk is cheap, show me the code</summary>
<p>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100500</span>;</span><br><span class="line"><span class="keyword">int</span> d[N], n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))&#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val, pos;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;i) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (val == i.val) <span class="keyword">return</span> pos &lt; i.pos;</span><br><span class="line">		<span class="keyword">return</span> val &lt; i.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;x;x -= low(x)) tmp += d[x];</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;x &lt;= n; x += low(x)) d[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node i,node j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i.pos &lt; j.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) p[i] = (node)&#123;read(),i&#125;;</span><br><span class="line">	sort(p + <span class="number">1</span>,p + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) p[i].val = i;</span><br><span class="line">	sort(p + <span class="number">1</span>,p + n + <span class="number">1</span>, cmp);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		add(p[i].val);</span><br><span class="line">		ans = max(ans, i - get(p[i].val));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>


<h2 id="2-P4375-Out-of-Sorts-G"><a href="#2-P4375-Out-of-Sorts-G" class="headerlink" title="2.P4375 Out of Sorts G"></a>2.<a href="https://www.luogu.org/problem/P4375" target="_blank" rel="noopener">P4375 Out of Sorts G</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sorted &#x3D; false</span><br><span class="line">while (not sorted):</span><br><span class="line">   sorted &#x3D; true</span><br><span class="line">   moo</span><br><span class="line">   for i &#x3D; 0 to N-2:</span><br><span class="line">      if A[i+1] &lt; A[i]:</span><br><span class="line">         swap A[i], A[i+1]</span><br><span class="line">   for i &#x3D; N-2 downto 0:</span><br><span class="line">      if A[i+1] &lt; A[i]:</span><br><span class="line">         swap A[i], A[i+1]</span><br><span class="line">   for i &#x3D; 0 to N-2:</span><br><span class="line">      if A[i+1] &lt; A[i]:</span><br><span class="line">         sorted &#x3D; false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给定一个输入数组，请预测Bessie的代码会输出多少次“moo”。</p>
</blockquote>
<p>题意:求双向冒泡排序的排序次数</p>
<h3 id="对于一个序列-我们称之为有序的-当且仅当对于任意一个位置前面没有比它大的数-可以模拟一下-1"><a href="#对于一个序列-我们称之为有序的-当且仅当对于任意一个位置前面没有比它大的数-可以模拟一下-1" class="headerlink" title="对于一个序列, 我们称之为有序的, 当且仅当对于任意一个位置前面没有比它大的数(可以模拟一下)"></a>对于一个序列, 我们称之为有序的, 当且仅当对于任意一个位置前面没有比它大的数(可以模拟一下)</h3><p>我们暂且称它为平衡条件吧</p>
<p>首先将序列离散化</p>
<p>相比较于Out of Sorts S, 本题思路在于不动的位置, 结论为对于位置x, ans = max{ans, 前面有几个数的数值大于x}</p>
<p>为什么呢</p>
<p>在x不满足平衡条件的时候</p>
<h3 id="首先第一波操作的时候-对于前x个位置一定会换出一个大于x的数"><a href="#首先第一波操作的时候-对于前x个位置一定会换出一个大于x的数" class="headerlink" title="首先第一波操作的时候,对于前x个位置一定会换出一个大于x的数"></a>首先第一波操作的时候,对于前x个位置一定会换出一个大于x的数</h3><p>因为它不满足平衡条件</p>
<h3 id="第二波操作时-又会有一个小于等于x的数插回来"><a href="#第二波操作时-又会有一个小于等于x的数插回来" class="headerlink" title="第二波操作时, 又会有一个小于等于x的数插回来"></a>第二波操作时, 又会有一个小于等于x的数插回来</h3><p>因为回来的时候一定会冒泡出一个位置在x后的最小值, 因为x不满足平衡条件, 所以最小值小于等于x, 就又插了回来</p>
<p>有人可能会问为什么Out of Sorts S不能用这个式子嘞, 因为每次换出的一定大于x, 但x+1位置上的数可能换过来, 而它有可能大于x</p>
<p>由此可知, 求每个位置前大于其的数就行啦</p>
<details><summary>talk is cheap, show me the code</summary>
<p>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100500</span>;</span><br><span class="line"><span class="keyword">int</span> d[N], n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))&#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val, pos;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;i) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (val == i.val) <span class="keyword">return</span> pos &lt; i.pos;</span><br><span class="line">		<span class="keyword">return</span> val &lt; i.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;x;x -= low(x)) tmp += d[x];</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;x &lt;= n; x += low(x)) d[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node i,node j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i.pos &lt; j.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) p[i] = (node)&#123;read(),i&#125;;</span><br><span class="line">	sort(p + <span class="number">1</span>,p + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) p[i].val = i;</span><br><span class="line">	sort(p + <span class="number">1</span>,p + n + <span class="number">1</span>, cmp);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		add(p[i].val);</span><br><span class="line">		ans = max(ans, i - get(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">2 5 6 3 1 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</p>
</details>

<h2 id="3-P4372-Out-of-Sorts-P"><a href="#3-P4372-Out-of-Sorts-P" class="headerlink" title="3.P4372 Out of Sorts P"></a>3.<a href="https://www.luogu.org/problem/P4372" target="_blank" rel="noopener">P4372 Out of Sorts P</a></h2><blockquote>
<p>留意着农场之外的长期职业生涯的可能性，奶牛Bessie开始在不同的在线编程网站上学习算法。她最喜欢的两个算法是“冒泡排序”和“快速排序”，但是不幸的是Bessie轻易地把它们搞混了，最后实现了一个奇怪的混合算法！ 如果数组<em>A</em>中A[…i]的最大值不大于A[i+1…]的最小值，我们就称元素i和i+1之间的位置为一个“分隔点”。Bessie还记得快速排序包含对数组的重排，产生了一个分隔点，然后要递归对两侧的A[…i]和A[i+1…]排序。然而，尽管她正确地记下了数组中所有的分隔点都可以在线性时间内被求出，她却忘记快速排序应该怎么重排来快速构造一个分隔点了！在这个可能会被证明是排序算法的历史中最糟糕的算法性失误之下，她做出了一个不幸的决定，使用冒泡排序来完成这个任务。</p>
<p>以下是Bessie最初的对数组A<em>A</em>进行排序的实现的概要。她首先写了一个简单的函数，执行冒泡排序的一轮：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bubble_sort_pass (A) &#123;</span><br><span class="line">   for i &#x3D; 0 to length(A)-2</span><br><span class="line">      if A[i] &gt; A[i+1], swap A[i] and A[i+1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>她的快速排序（相当快）函数的递归代码是按下面的样子构成的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quickish_sort (A) &#123;</span><br><span class="line">   if length(A) &#x3D; 1, return</span><br><span class="line">   do &#123; &#x2F;&#x2F; Main loop</span><br><span class="line">      work_counter &#x3D; work_counter + length(A)</span><br><span class="line">      bubble_sort_pass(A)</span><br><span class="line">   &#125; while (no partition points exist in A) </span><br><span class="line">   divide A at all partition points; recursively quickish_sort each piece</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Bessie好奇于她的代码能够运行得多快。简单起见，她计算出她得主循环的每一轮都消耗线性时间，所以她相应增加一个全局变量work_counter的值，以此来跟踪整个算法总共完成的工作量。</p>
<p>给定一个输入数组，请预测quickish_sort函数接收这个数组之后，变量work_counter的最终值。</p>
</blockquote>
<h3 id="这道题用到了一个套路-就是”横向变纵向”"><a href="#这道题用到了一个套路-就是”横向变纵向”" class="headerlink" title="这道题用到了一个套路, 就是”横向变纵向”"></a>这道题用到了一个套路, 就是”横向变纵向”</h3><p>求每一次冒泡排序的长度, 不如求每一个点被冒泡排序了几次</p>
<p>定义分割点为i与i+1的分割线,不妨假设它就在i上吧</p>
<p>再次定义序列排好序的标准</p>
<h3 id="我们称一个序列是有序的当且仅当所有点-除了n-都是分割点"><a href="#我们称一个序列是有序的当且仅当所有点-除了n-都是分割点" class="headerlink" title="我们称一个序列是有序的当且仅当所有点(除了n)都是分割点"></a>我们称一个序列是有序的当且仅当所有点(除了n)都是分割点</h3><p>那么接下来我们要求分割点的出现时间t数组</p>
<h3 id="为什么求"><a href="#为什么求" class="headerlink" title="为什么求:"></a>为什么求:</h3><p>对于每个点它不用在进行冒泡排序了当且仅当两边都已成为分割点, 也就是两边出现时间的最大值</p>
<p>依据t数组,我们可以求出每个点被排了几次</p>
<h3 id="怎么求-敲重点"><a href="#怎么求-敲重点" class="headerlink" title="怎么求(敲重点):"></a>怎么求(敲重点):</h3><p>首先离散化</p>
<p>对于一个点x来说, 所有小于它的数却在它后面的, 每一次都会向前走一次</p>
<p>那么它出现的时间就是离它最远的小于它的点冒泡到它前面的时间</p>
<p>即那个点到它的距离, 具体见代码</p>
<p>所以单调队列或指针都可以维护</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100500</span>;</span><br><span class="line"><span class="keyword">int</span> d[N], n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))&#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val, pos;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;i) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (val == i.val) <span class="keyword">return</span> pos &lt; i.pos;</span><br><span class="line">		<span class="keyword">return</span> val &lt; i.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node i,node j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i.pos &lt; j.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t[N], k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	freopen("hs.in","r",stdin);</span></span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) p[i] = (node)&#123;<span class="built_in">read</span>(),i&#125;;</span><br><span class="line">	sort(p + <span class="number">1</span>,p + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) p[i].val = i;</span><br><span class="line">	sort(p + <span class="number">1</span>,p + n + <span class="number">1</span>, cmp);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	k = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">while</span> (p[k].val &gt; i) k--;</span><br><span class="line">		t[i] = <span class="built_in">max</span>(p[k].pos - i, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) ans += <span class="built_in">max</span>(t[i], t[i+<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">2 5 6 3 1 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</p>
</details>


<h2 id="4-T99343-奇怪的排序"><a href="#4-T99343-奇怪的排序" class="headerlink" title="4.T99343 奇怪的排序"></a>4.<a href="https://www.luogu.org/problem/T99343" target="_blank" rel="noopener">T99343 奇怪的排序</a></h2><blockquote>
<p>您有一个正整数序列, 您可以选择任意相邻的两个数$a_i,a_{i+1}$插入另两个数之间,或序列首和尾;<br>假如序列为: 1 2 4 3 5 6<br>可以选2 4<br>插在序列首 2 3 4 3 5 6<br>插到3后 1 3 2 4 5 6<br>插到5后 4 3 5 1 2 6<br>插在6后 1 3 5 6 2 4<br>现在hs-black需要判断是否进行若干次操作能使序列变得有序(无论正序倒序), 蒟蒻hs-black当然不会啦, 请您帮帮他…..</p>
</blockquote>
<p>这道题来源于一位数竞大佬提供的灵感</p>
<p>再次定义一个序列有序</p>
<p>我们称一个序列是有序的,当且仅当它的逆序对数为0或n*(n-1)/2;</p>
<p>引理1: 交换序列中相邻的两个数会改变原序列逆序对个数的奇偶性</p>
<p>引理2: 将序列相邻两个数插入别处不会改变原序列逆序对个数的奇偶性</p>
<p>​    证明: a~1~…a~i~a~j~…a~q~…a~n~  不断将a~j~与它右边的数字交换直至正好换到a~q~ 即a~1~…a~j~a~i~…a~n~ 此时共交换了q - j 次</p>
<p>​    再将a~i~ 向右与相邻数字交换q-1-i次到$a_j$左侧 ,此时共交换2 * (q - j) 次,为偶数次,所以奇偶性不变</p>
<p>那么说明逆序对数与排序好的逆序对数奇偶性不同时不能满足要求</p>
<p>下面证明相同时可以满足要求</p>
<p>以正序为例, 每次将序列最小的数和后面的数插到已排序部分的后面, 如果最小数在最后时就将后2,3个数插在它后面</p>
<p>当未排序列只剩两个数时, 逆序对个数也一定是偶数, 只可能是0</p>
<p>即序列有序, 证毕</p>
<p>具体实现是讨论一下n*(n-1)/2的奇偶性, 并树状数组求出原序列逆序对个数</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, sum[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,num;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Num a,Num b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;=n)&#123;</span><br><span class="line">    	sum[k]+=x;</span><br><span class="line">    	k+=lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        tmp+=sum[k];</span><br><span class="line">        k-=lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ss[<span class="number">1</span>&lt;&lt;<span class="number">17</span>],*A=ss,*B=ss;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">if</span>(A==B)&#123;B=(A=ss)+fread(ss,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">17</span>,<span class="built_in">stdin</span>);<span class="keyword">if</span>(A==B)<span class="keyword">return</span> EOF;&#125;<span class="keyword">return</span>*A++;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp;<span class="title">x</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	read(t);</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		Ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">    	read(n);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    		read(p[i].val);</span><br><span class="line">        	p[i].num=i;</span><br><span class="line">    	&#125;</span><br><span class="line">    	sort(p+<span class="number">1</span>,p+n+<span class="number">1</span>);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        	add(p[i].num,<span class="number">1</span>);</span><br><span class="line">        	Ans+=getsum(p[i].num<span class="number">-1</span>);</span><br><span class="line">    	&#125;</span><br><span class="line"><span class="comment">//    	printf ("%lld\n", Ans);</span></span><br><span class="line">    	<span class="keyword">if</span> (n % <span class="number">4</span> &gt; <span class="number">1</span>) </span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (Ans % <span class="number">2</span> == <span class="number">1</span>) </span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>



<hr>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
        <tag>人类智慧</tag>
      </tags>
  </entry>
  <entry>
    <title>计数问题学习笔记</title>
    <url>/2019/12/29/%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="计数问题学习笔记"><a href="#计数问题学习笔记" class="headerlink" title="计数问题学习笔记"></a>计数问题学习笔记</h1><h1 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h1><h2 id="插板法-略"><a href="#插板法-略" class="headerlink" title="插板法: 略"></a>插板法: 略</h2><h2 id="阶乘幂"><a href="#阶乘幂" class="headerlink" title="阶乘幂:"></a>阶乘幂:</h2><h3 id="上升阶乘幂"><a href="#上升阶乘幂" class="headerlink" title="上升阶乘幂:"></a>上升阶乘幂:</h3><script type="math/tex; mode=display">(x)^{(n)} = x(x+1)(x+2)\cdots(x+n-1) = \frac{(x+n-1)!}{(x-1)!}</script><h3 id="下降阶乘幂"><a href="#下降阶乘幂" class="headerlink" title="下降阶乘幂:"></a>下降阶乘幂:</h3><p>$(x)_{(n)}$</p>
<a id="more"></a>
<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数:"></a>卡特兰数:</h2><p>定义式 <script type="math/tex">h_n = \displaystyle\sum^{n-1}_{k=0}h_kh_{n-1-k}</script></p>
<p>通项式 <script type="math/tex">h_n = \tbinom{2n}{n}-\tbinom{2n}{n-1} = \frac{\tbinom{2n}{n}}{n+1}</script></p>
<p>应用: 括号序列数量, 方格行走数, 凸多边形划分数, 二叉树数量</p>
<h3 id="通项证明"><a href="#通项证明" class="headerlink" title="通项证明:"></a>通项证明:</h3><p>2n步选n步向斜上走方案数为$\tbinom{2n}{n}$</p>
<p>如果走到负区域, 则一定与2n步选n-1步斜向上走的方案数相同</p>
<p>在一条路径第一次触到直线y=-1时, 将其以后的路径关于y=-1对称</p>
<p>走2n步最终到达点(2n, -2)</p>
<p>每一条到达点(2n, -2)的路径都可以如此转化</p>
<h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数:"></a>第一类斯特林数:</h2><p>$ S_u(n, m)$表示n个不同元素构成恰好m个圆排列的方案数</p>
<p>$S_u(n,m) = S_u(n-1,m-1) + (n-1) * S_u(n-1,m)$</p>
<p>有符号: $S_s(n, m) = (-1)^{n+m}S_u(n,m)$</p>
<p>有符号的生成函数: $(x)_{(n)}$ (x的n次下降幂)</p>
<h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数:"></a>第二类斯特林数:</h2><p>$S(n,m)$表示n个不同元素拆分成m个非空集合方案数</p>
<script type="math/tex; mode=display">S(n,m) = S(n-1,m-1) + m * S(n-1, m)</script><p>生成函数</p>
<script type="math/tex; mode=display">S(n,m) = \frac{1}{m!}\sum(-1)^k\tbinom{m}{k}(m-k)^n</script><p>贝尔数为第二类斯特林数之和</p>
<h2 id="拆分数"><a href="#拆分数" class="headerlink" title="拆分数:"></a>拆分数:</h2><p>$f_n$表示大小为n的正整数拆分成若干无序的正整数之和的方案数</p>
<h3 id="dp求解"><a href="#dp求解" class="headerlink" title="dp求解"></a>dp求解</h3><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一:"></a>方案一:</h3><p> f[i][j]表示拆分成若干不超过j的方案数</p>
<p>f[i][j] = f[i-j][j] +f[i][j-1]</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二:"></a>方案二:</h3><p>g[i][j]表示拆分j个数字的方案数</p>
<p>g[i][j] = g[i-1][j] + g[i-j][j]</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化:"></a>优化:</h3><p>易知任意一个复杂度都是$n^2$</p>
<p>结合两者, 复杂度为$n\sqrt{n}$</p>
<p>首先用方案一跑出所有用不超过$\sqrt{n}$数字大小拼出1~n的方案数</p>
<p>复杂度$n\sqrt{n}$  存疑</p>
<h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><h2 id="基础闭形式"><a href="#基础闭形式" class="headerlink" title="基础闭形式:"></a>基础闭形式:</h2><ol>
<li><h3 id="sum-n-ge-0-x-n-frac-1-1-x"><a href="#sum-n-ge-0-x-n-frac-1-1-x" class="headerlink" title="$\sum_{n \ge 0} x^n=\frac{1}{1-x}$"></a>$\sum_{n \ge 0} x^n=\frac{1}{1-x}$</h3></li>
<li><h3 id="sum-n-ge-1-x-n-frac-x-1-x"><a href="#sum-n-ge-1-x-n-frac-x-1-x" class="headerlink" title="$\sum_{n \ge 1} x^n=\frac{x}{1-x}$"></a>$\sum_{n \ge 1} x^n=\frac{x}{1-x}$</h3><p>$\sum_{n \ge 1} x^n=x*(\sum_{n \ge 0} x^n)$</p>
</li>
<li><h3 id="sum-n-ge-1-n-x-n"><a href="#sum-n-ge-1-n-x-n" class="headerlink" title="$\sum_{n \ge 1} n x^n=$?"></a>$\sum_{n \ge 1} n x^n=$?</h3><p>​    $(\sum_{n \ge 0} x^n)’=(\frac{1}{1-x})’$</p>
<p>​    $\sum_{n \ge 0} (n+1)x^n=\frac{1}{(1-x)^2}$</p>
<p>​    $\sum_{n \ge 0} (n+1)x^{n+1}=\frac{x}{(1-x)^2}$    </p>
<p>​    $(\sum_{n \ge 0} x^n)*(\sum_{n \ge 0} x^n)=\sum_{n \ge 0} (n+1)x^n=\frac{1}{(1-x)^2}$    </p>
</li>
<li><h3 id="sum-n-ge-0-frac-1-n-x-n-e-x"><a href="#sum-n-ge-0-frac-1-n-x-n-e-x" class="headerlink" title="$\sum_{n \ge 0} \frac{1}{n!}x^n=e^x$"></a>$\sum_{n \ge 0} \frac{1}{n!}x^n=e^x$</h3></li>
</ol>
<ul>
<li><h3 id="加法意义-合并"><a href="#加法意义-合并" class="headerlink" title="加法意义: 合并"></a>加法意义: 合并</h3></li>
<li><h3 id="乘法意义-拼接"><a href="#乘法意义-拼接" class="headerlink" title="乘法意义:拼接"></a>乘法意义:拼接</h3></li>
</ul>
<h2 id="例-求斐波那契数列的通项公式"><a href="#例-求斐波那契数列的通项公式" class="headerlink" title="例: 求斐波那契数列的通项公式"></a>例: 求斐波那契数列的通项公式</h2><p>因为F(x) = F(x-1) + F(x-2)</p>
<script type="math/tex; mode=display">
~~~~~~F(0)~~~F(1)~~~~    F(2)~~~~    F(3)~~~~F(4)\\

​         ~~~~~~~~~~~~~~~~~ F(0)    ~~~~F(1)    ~~~~F(2)    ~~~~F(3)\\

​~~~~~~~~~~~~~~~~~~~~~~~~~~~~~F(0)~~~~    F(1)~~~~    F(2)</script><p>发现最上面的生成函数由下面两个推出</p>
<p>所以$F(x) = x \cdot F(x-1) + x^2 \cdot F(x-2)$ + 1</p>
<p>解得F(x)的闭形式为$\frac{1}{1-x-x^2}$</p>
<p>那么如何求通项公式呢?</p>
<h2 id="前置"><a href="#前置" class="headerlink" title="前置:"></a>前置:</h2><p>$\sum_{n \ge 0} x^n=\frac{1}{1-x}$</p>
<p>$\sum_{n \ge 0} (kx)^n=\frac{1}{1-kx}$ (将x变为kx即可)</p>
<p>$\sum_{n \ge 0} ax^n=\frac{a}{1-x}$</p>
<p>发现如果把它化成类似$\frac{a}{1-kx}$的形式是再好不过了</p>
<p>所以将$1-x-x^2$因式分解, 再进行裂项</p>
<p>设$t_1, t_2$为其的两根</p>
<p>最后化成$\frac{a}{1-t_1x} - \frac{b}{1-t_2x}$的形式</p>
<p>$A_n = a \cdot t_1^n - b * t_2^n$</p>
<p><del>好像不是很难的鸭子</del></p>
<h2 id="指数级生成函数"><a href="#指数级生成函数" class="headerlink" title="指数级生成函数:"></a>指数级生成函数:</h2><p>处理<strong>有标号</strong>问题时, 通常使用指数级生成函数</p>
<p>生成函数: $\displaystyle\sum _{n\ge0}\frac{A_n}{n!}x^n$</p>
<hr>
]]></content>
      <categories>
        <category>数学</category>
        <category>计数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀自动机感性理解</title>
    <url>/2019/12/29/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%84%9F%E6%80%A7%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="后缀自动机感性理解"><a href="#后缀自动机感性理解" class="headerlink" title="后缀自动机感性理解"></a>后缀自动机感性理解</h1><p>后缀自动机实是不是很好理解, 尤其是直接看大段的证明, 不知道它在干什么, 可能会有点懵</p>
<p>那我先介绍一下我的感性理解好了, 大家看这篇文章可能会更好的理解其他人的博客QAQ<br><a id="more"></a></p>
<h3 id="前置芝士-trie树"><a href="#前置芝士-trie树" class="headerlink" title="前置芝士 : trie树"></a>前置芝士 : trie树</h3><p>先来讲一下假后缀树($ n^2 $) , 由于它是假的所以很容易理解, 不用怕</p>
<p>偷图.jpg</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/f2wqgie6.png" alt=""></p>
<p>对于一个字符串(例: $bananas$)来说, 把它的所有后缀($bananas, ananas, nanas, anas, nas, as, s $) 一个一个的插入trie树, 并在末尾打上end标记, 就是暴力的后缀$trie$了, 显然时空复杂度均为$O(n^2)$ </p>
<p>那么可以说后缀自动机是对它很大程度上的优化了, 也就是对重复出现的子串和后缀进行压缩等操作, 使时空复杂度骤降为 $O(n)$, 并具有后缀树的一些性质</p>
<p><strong>关于子串的理解: 对于字符串S的一个子串, 你可以理解它为((S的一个后缀)的前缀), 没毛病</strong></p>
<p>也就是如果S的一个子串在trie上一定是一条从根节点开始的路径</p>
<h3 id="有啥用呢"><a href="#有啥用呢" class="headerlink" title="有啥用呢"></a>有啥用呢</h3><ul>
<li>找一个子串的出现次数: 在trie上找到它的路径, 在它下方的end标记之和, 也就是它是多少个后缀的前缀</li>
<li>找一个子串第一次(最后一次)出现位置, 同上, 就是向下走到深度最大(深度最小)的end标记</li>
<li>统计本质不同子串的个数, 即trie树上节点的个数</li>
</ul>
<h3 id="开始切入后缀自动机"><a href="#开始切入后缀自动机" class="headerlink" title="开始切入后缀自动机:"></a>开始切入后缀自动机:</h3><p>后缀自动机神奇的连了一大堆边, 成功的压缩了空间与时间</p>
<p>他有一个小性质: 从始节点开始, 走任意路径, 到终止节点的路径均是原字符串的一个后缀, 终止节点可能不止一个</p>
<p>先贴一张图, 来自zjp大佬的博客, 方便理解性质:</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/2bd4ix68.png" alt=""></p>
<p>几个必备要素:</p>
<p><strong>endpos(x)</strong>: 它是一个集合, 表示一个子串的所有结束位置(可能有许多结束位置, 因为会有本质相同子串), 如果两个子串的$endpos$相同, 那么这两个子串属于一个”状态” , 同时他俩一个是另一个的后缀</p>
<p><strong>len(x) </strong>: 对于一个状态所表示的一堆字符串, 他们最长的那个的长度, 同时这些字符串按长度排个序, 长度是连续的整数</p>
<p><strong>后缀link:</strong></p>
<p>设一个A状态如($”abab”, “bab”, “ab”$) 那么$”b”$就是状态中没有的最长后缀, 即$”abab”$(或$bab”$等)的最长的且没有在该状态出现的后缀</p>
<p>那么我将A状态向”b”状态所在的B状态连有向边, 叫做link, 如果从一个状态不断的跳link, 那么就会遍历一个字符串的所有后缀</p>
<p>转移函数: 在一个状态的末尾加一个字符使它转向另一个状态, 可以证明在同一个状态的字符串在末尾加一个字符后还在同一个状态</p>
<p>下面来讲构造:</p>
<p>考虑从前往后一个一个加入字符, 即增量法, 这样就保证了每加一个字符都满足后缀自动机的性质</p>
<p>设当前最长串为$S[1…i-1]$, 现在加一个字符$S[i]$, 我们要干的事就是让它的所有后缀都能从起点开始走一条路径表示出来</p>
<p>$S[1…i]$肯定是一个新状态, 因为他是最长的, 设这个转态为np</p>
<p>因为前面$S[1…i-1]$已经构造好了, 我们从状态$p = {s[1…i-1]}$开始往前跳, 刚才说了, 往前跳的过程中会遍历它的所有后缀, 那么我们直接从以前的状态向他连一条边, 就可以从以前的状态转移到他了, 虽然这还是O($n^2$)的错误解法, 但给我们提供了不错的思路</p>
<p>设$ch[s][‘a’-‘z’]$为它的转移函数, 如$ch[s][‘a’]$表示从s状态加一个’a’字符转移到哪个转态</p>
<p>设加入字符c, 向刚才一样跳link, 设到了状态A, 如果ch[A][c] == 0, 直接让ch[A][c] = np, 然后继续跳link, 最后如果跳到了根节点, 那他的link就是初始状态</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !ch[p][c]; p = f[p]) ch[p][c] = np;</span><br><span class="line"><span class="keyword">if</span> (!p) f[np] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果碰到了$ch[A][c] = q(q \not= 0$), 分两种情况</p>
<p>如果$len(p) = len(q) + 1, $那么使q成为终止状态, $np$向$q link$一下</p>
<p>否则, 原先p中的字符串集就不再有相同的$endpos$, 因为从A转移过来的串也是S[1…n]的后缀, 所以这部分$endpos$会多一个$(i)$, 这个状态就会分裂, 因此我们新建一个状态$nq$去让多出的部分转移, $p$将转移到$nq$, $nq$再转移到$np$, 同时$q$和$np$都将向$nq$ $link$</p>
<p>看看图理解一下(大佬讲的很好)</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/2s825d6e.png" alt=""></p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = las, np = las = ++cnt; zhi[cnt] = <span class="number">1</span>;</span><br><span class="line">	len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; p &amp;&amp; !ch[p][c]; p = f[p]) ch[p][c] = np;</span><br><span class="line">	<span class="keyword">if</span> (!p) f[np] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">		<span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) f[np] = q;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> nq = ++cnt;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>; i++)</span><br><span class="line">			ch[nq][i] = ch[q][i];</span><br><span class="line">			len[nq] = len[p] + <span class="number">1</span>, f[nq] = f[q];</span><br><span class="line">			f[q] = f[np] = nq;</span><br><span class="line">			<span class="keyword">for</span> (; p &amp;&amp; ch[p][c] == q;p = f[p]) ch[p][c] = nq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</p>
</details>




<hr>
]]></content>
      <categories>
        <category>字符串</category>
        <category>后缀自动机</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式全家桶</title>
    <url>/2019/12/29/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6-%E6%9C%AA%E5%AE%8C/</url>
    <content><![CDATA[<h1 id="多项式全家桶-更新至开根"><a href="#多项式全家桶-更新至开根" class="headerlink" title="多项式全家桶(更新至开根)"></a>多项式全家桶(更新至开根)</h1><p>开始爆肝多项式</p>
<h2 id="1-FFT快速傅里叶变换"><a href="#1-FFT快速傅里叶变换" class="headerlink" title="1. FFT快速傅里叶变换"></a>1. FFT快速傅里叶变换</h2><p>流程: 将多项式$\Theta (nlog_n)$转成点值表示形式 进行卷积, 再$\Theta (nlog_n)$ 转回来</p>
<h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换:"></a>离散傅里叶变换:</h3><p>朴素转为点值, 需要将一个一个x带入, 而这里傅里叶搞到了几个可以优化的复数根</p>
<p>利用复数, 在复平面上画出一个单位圆, 将单位圆n等分, 每一个等分点为$\omega_n^i $,</p>
<p>接下来将$\omega^1_n \omega^2_n\cdots\omega^n_n$ n个根带入, 其中$\omega_n^i = cos(\frac{k}{n}2\pi) + i * sin(\frac{k}{n}2\pi)$<br><a id="more"></a></p>
<p><strong>稍等, 还要几个小性质才可以:</strong></p>
<h3 id="性质一-omega-2k-2n-omega-n-k"><a href="#性质一-omega-2k-2n-omega-n-k" class="headerlink" title="性质一:  $\omega^{2k}_{2n} = \omega_n^k$"></a>性质一:  $\omega^{2k}_{2n} = \omega_n^k$</h3><h3 id="性质二-omega-n-k-frac-n-2-omega-n-k"><a href="#性质二-omega-n-k-frac-n-2-omega-n-k" class="headerlink" title="性质二: $\omega_n^{k+\frac{n}{2}} = - \omega_n^k$"></a>性质二: $\omega_n^{k+\frac{n}{2}} = - \omega_n^k$</h3><h3 id="接下来开始快速傅里叶变换"><a href="#接下来开始快速傅里叶变换" class="headerlink" title="接下来开始快速傅里叶变换:"></a>接下来开始快速傅里叶变换:</h3><p>设A(x) = $a_0 + a_1x + a_2x^2 + \cdots + a_{n-1}x^{n-1}$</p>
<p>利用分治, 将A按x的指数分为奇偶两部分</p>
<p>$A(x)=(a_0+a_2x^2+\cdots + a_{n-2}x^{n-2})+(a_1x+a_3x^3+\cdots$ $ a_{n-1}x^{n-1})$</p>
<p>设偶部分 $A_1(x) = a_0 + a_2x + a_4x^2 + \cdots + a_{n-2}x^{\frac{n}{2}-1}$</p>
<p>奇部分$A_2(x) = a_1 + a_3x + a_5x^2 + \cdots + a_{n-1}x^{\frac{n}{2}-1}$</p>
<p>则有: $A(x) = A_1(x^2) + x  A_2(x^2)$</p>
<p>设k &lt; n/2 带入$x = \omega^k_n$ </p>
<p>$A(\omega^k_n) = A_1(\omega^{2k}_n) + \omega_n^kA_2(\omega^{2k}_n)$</p>
<p>再带入 $\omega^{k+\frac{n}{2}}_n$ </p>
<p>得$A(\omega^{k+\frac{n}{2}}_n) = A_1(\omega^{2k}_n)  -\omega_n^kA_2(\omega^{2k}_n)$</p>
<p>你fa♂现了吗, 分治时, 两个求值一次解决</p>
<h3 id="IDFT-离散傅里叶逆变换"><a href="#IDFT-离散傅里叶逆变换" class="headerlink" title="IDFT: 离散傅里叶逆变换"></a>IDFT: 离散傅里叶逆变换</h3><p>设$(y_0,y_1,\cdots,y_{n-1})$ 为多项式A(x) = $a_0 + a_1x + a_2x^2 + \cdots + a_{n-1}x^{n-1}$的离散傅里叶变换</p>
<p>设多项式 B(x) = A(x) = $y_0 + y_1x + y_2x^2 + \cdots + y_{n-1}x^{n-1}$</p>
<p>将n个单位根的倒数带入得新的离散傅里叶变换</p>
<p>此处略去推导, 得$a_i = \frac{z_i}{n}$</p>
<p>非递归版fft</p>
<p>每个数递归到底层时的二进制表示恰是原来的表示翻转得到的</p>
<p>如 6(011) 到 3(110)</p>
<p>再加上蝴蝶变换就可以啦</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000600</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span> (f) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> x, y;</span><br><span class="line">	Complex (<span class="keyword">double</span> xx = <span class="number">0</span>,<span class="keyword">double</span> yy = <span class="number">0</span>) &#123;x=xx,y=yy;&#125;</span><br><span class="line">	Complex <span class="keyword">operator</span> + (Complex &amp;i) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Complex(x + i.x, y + i.y);</span><br><span class="line">	&#125;</span><br><span class="line">	Complex <span class="keyword">operator</span> - (Complex &amp;i) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Complex(x - i.x, y - i.y);</span><br><span class="line">	&#125;</span><br><span class="line">	Complex <span class="keyword">operator</span> * (Complex &amp;i) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Complex(x * i.x - y * i.y, x * i.y + y * i.x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;A[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim = <span class="number">1</span>, L;</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *a,<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">	<span class="keyword">if</span> (r[i] &gt; i) swap(a[r[i]], a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>;mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="function">Complex <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi/mid), type * <span class="built_in">sin</span>(Pi/mid))</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="function">Complex <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; mid; k++, t = t * T) &#123;</span><br><span class="line">				Complex x = a[j + k], y = t * a[mid + j + k];</span><br><span class="line">				a[k + j] = x + y;</span><br><span class="line">				a[mid + j + k] = x - y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n), read(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x; read(x);</span><br><span class="line">		A[i].x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x; read(x);</span><br><span class="line">		B[i].x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (lim &lt;= (n + m)) lim &lt;&lt;= <span class="number">1</span>, L++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">	r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">	</span><br><span class="line">	FFT(A, <span class="number">1</span>); FFT(B, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= lim; i++) A[i] = A[i] * B[i];</span><br><span class="line">	FFT(A, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n + m; i++)</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d "</span>, (<span class="keyword">int</span>)(A[i].x / lim + <span class="number">0.5</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>

<h2 id="2-NTT快速数论变换"><a href="#2-NTT快速数论变换" class="headerlink" title="2.NTT快速数论变换"></a>2.NTT快速数论变换</h2><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Gi = (P+<span class="number">1</span>)/G;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, r[N], L;</span><br><span class="line">ll A[N], B[N];</span><br><span class="line"><span class="keyword">int</span> lim = <span class="number">1</span>;</span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll di,ll mi)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>, a = di;</span><br><span class="line">	<span class="keyword">while</span> (mi) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mi &amp; <span class="number">1</span>) ans = ans * a % P;</span><br><span class="line">		a = a * a % P;</span><br><span class="line">		mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a, <span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">	<span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>;mid &lt; lim ;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		ll wn = <span class="built_in">pow</span>(tag == <span class="number">1</span> ? G : Gi, (P<span class="number">-1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; lim; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">			ll w = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; mid ; k++, w = (w * wn) % P) &#123;</span><br><span class="line">				ll x = a[j+k], y = w * a[j+k+mid] % P;</span><br><span class="line">				a[j+k] = (x + y) % P;</span><br><span class="line">				a[j+k+mid] = (x - y + P) % P;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(), m = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n; i++) A[i] = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m; j++) B[j] = read();</span><br><span class="line">	<span class="keyword">while</span> (lim &lt;= n + m) L++, lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">	r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">	NTT(A, <span class="number">1</span>), NTT(B, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= lim; i++) A[i] = (A[i] * B[i]) % P;</span><br><span class="line">	NTT(A, <span class="number">-1</span>);</span><br><span class="line">	ll inv = <span class="built_in">pow</span>(lim, P<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n + m; i++) </span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d "</span>, A[i] * inv % P);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>


<h2 id="3-多项式求逆"><a href="#3-多项式求逆" class="headerlink" title="3.多项式求逆"></a>3.多项式求逆</h2><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Gi = (P+<span class="number">1</span>)/G;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>) + c-<span class="string">'0'</span>;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line">ll A[N], n, lim = <span class="number">1</span>, L;</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll di,ll mi)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (mi) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mi &amp; <span class="number">1</span>) ans = (ans * di) % P;</span><br><span class="line">		di = (di * di) % P;</span><br><span class="line">		mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">	<span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>;mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		ll wn = <span class="built_in">pow</span>(type == <span class="number">1</span> ? G : Gi, (P<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; lim;j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">			ll w = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; mid; k++, w = (w * wn) % P) &#123;</span><br><span class="line">				ll x = a[j+k], y = w * a[j+k+mid] % P;</span><br><span class="line">				a[j+k] = (x + y) % P, a[j+k+mid] = (x - y + P) % P;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	ll inv = <span class="built_in">pow</span>(lim, P<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">	a[i] = a[i] * inv % P;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">ll B[N], C[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> deg, ll *a, ll *b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">		b[<span class="number">0</span>] = <span class="built_in">pow</span>(a[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	work((deg+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>, a, b);</span><br><span class="line">	lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (lim &lt; (deg&lt;&lt;<span class="number">1</span>)) lim &lt;&lt;= <span class="number">1</span>, L++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">	r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; deg; i++) C[i] = a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) C[i] = <span class="number">0</span>;</span><br><span class="line">	NTT(C, <span class="number">1</span>), NTT(b, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">	b[i] = ((ll)<span class="number">2</span> - C[i] * b[i] % P + P) % P * b[i] % P;</span><br><span class="line">	NTT(b, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) read(A[i]);</span><br><span class="line">	work(n, A, B);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) <span class="built_in">printf</span> (<span class="string">"%lld "</span>, B[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>

<h2 id="4-分治FFT"><a href="#4-分治FFT" class="headerlink" title="4.分治FFT"></a>4.分治FFT</h2><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>, Gi =  (P+<span class="number">1</span>) / G;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">405000</span>;</span><br><span class="line"><span class="function">ll <span class="title">fpw</span><span class="params">(ll di, ll mi)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (mi) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mi &amp; <span class="number">1</span>) res = res * di % P;</span><br><span class="line">		di = di * di % P;</span><br><span class="line">		mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim, L;</span><br><span class="line">ll r[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a,<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">		<span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>;mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		ll wn = fpw(type == <span class="number">1</span> ? G : Gi, (P<span class="number">-1</span>) / (mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">			ll w = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mid; j++, w = w * wn % P) &#123;</span><br><span class="line">				ll x = a[j + i], y = a[mid + i + j] * w % P;</span><br><span class="line">				a[i + j] = (x + y) % P;</span><br><span class="line">				a[i + j + mid] = (x - y + P) % P;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	ll inv = fpw(lim, P<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) a[i] = a[i] * inv % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[N], f[N], b[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == R) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	solve(l, mid); lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len = R - l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= mid; i++) a[i-l] = f[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; i++) b[i] = g[i];</span><br><span class="line">	len += mid - l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (lim &lt;= len) lim &lt;&lt;= <span class="number">1</span>, L++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">		r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">	NTT(a, <span class="number">1</span>), NTT(b, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) a[i] = a[i] * b[i] % P;</span><br><span class="line">	NTT(a, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>;i &lt;= R; i++) f[i] = (f[i] + a[i-l]) % P;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) a[i] = b[i] = <span class="number">0</span>;</span><br><span class="line">	solve(mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; i++) g[i] = read();</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	solve(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) <span class="built_in">printf</span> (<span class="string">"%lld "</span>, f[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>

<h2 id="5-多项式ln："><a href="#5-多项式ln：" class="headerlink" title="5.多项式ln："></a>5.多项式ln：</h2><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Gi = (P+<span class="number">1</span>) / G;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpw</span><span class="params">(ll di,ll mi)</span> </span>&#123;</span><br><span class="line">	ll ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (mi) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mi &amp; <span class="number">1</span>) ans = ans * di % P;</span><br><span class="line">		di = di * di % P;</span><br><span class="line">		mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll A[N], B[N], C[N];</span><br><span class="line"><span class="keyword">int</span> r[N], n, lim, L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">		<span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; lim; j &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		ll wn = fpw(type == <span class="number">1</span> ? G : Gi, (P<span class="number">-1</span>) / (j&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; lim; k += j &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">			ll w = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>;p &lt; j; p++, w = w * wn % P) &#123;</span><br><span class="line">				ll x = a[p+k], y = a[p+k+j] * w % P;</span><br><span class="line">				a[p+k] = (x + y) % P;</span><br><span class="line">				a[p+k+j] = (x - y + P) % P;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (~type) <span class="keyword">return</span>;</span><br><span class="line">	ll inv = fpw(lim, P<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">		a[i] = a[i] * inv % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> deg, ll *a, ll *b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">		b[<span class="number">0</span>] = fpw(a[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	work((deg+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>, a, b);</span><br><span class="line">	lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (lim &lt; (deg&lt;&lt;<span class="number">1</span>)) lim &lt;&lt;= <span class="number">1</span>, L++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">		r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; deg; i++) C[i] = a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) C[i] = <span class="number">0</span>;</span><br><span class="line">	NTT(C, <span class="number">1</span>); NTT(b, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">	b[i] = ((ll)<span class="number">2</span> - C[i] * b[i] % P + P) % P * b[i] % P;</span><br><span class="line">	NTT(b, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qiudoor</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; i++) A[i<span class="number">-1</span>] = A[i] * i % P;</span><br><span class="line">	A[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jinitaimei</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>; i--) A[i] = A[i<span class="number">-1</span>] * fpw(i, P<span class="number">-2</span>) % P;</span><br><span class="line">	A[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n  = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) A[i] = read();</span><br><span class="line">	work(n, A, B); qiudoor();</span><br><span class="line">	lim = <span class="number">1</span>, L = <span class="number">0</span>; m = n;</span><br><span class="line">	<span class="keyword">while</span> (lim &lt;= n + m) lim &lt;&lt;= <span class="number">1</span>, L++;</span><br><span class="line">	NTT(A, <span class="number">1</span>); NTT(B, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) A[i] = A[i] * B[i] % P;</span><br><span class="line">	NTT(A, <span class="number">-1</span>); </span><br><span class="line">	jinitaimei();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) <span class="built_in">printf</span> (<span class="string">"%lld "</span>, A[i] % P);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>


<h2 id="6-多项式exp"><a href="#6-多项式exp" class="headerlink" title="6.多项式exp"></a>6.多项式exp</h2><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>, Gi = (P+<span class="number">1</span>) / G;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpw</span><span class="params">(ll di, ll mi)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (mi) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mi &amp; <span class="number">1</span>) res = res * di % P;</span><br><span class="line">		di = di * di % P;</span><br><span class="line">		mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim, L;</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a,<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">		<span class="keyword">if</span> (r[i] &gt; i) swap(a[r[i]], a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>;mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		ll wn = fpw(type == <span class="number">1</span> ? G : Gi, (P<span class="number">-1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">			ll w = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mid; j++, w = w * wn % P) &#123;</span><br><span class="line">				<span class="keyword">int</span> x = a[i + j], y = a[i + j + mid] * w % P;</span><br><span class="line">				a[i + j] = (x + y) % P;</span><br><span class="line">				a[i + j + mid] = (x - y + P) % P;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	ll inv = fpw(lim, P<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) a[i] = a[i] * inv % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[N], b[N], c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> deg, ll *a, ll *b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">		b[<span class="number">0</span>] = fpw(a[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	work((deg+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>, a, b);</span><br><span class="line">	lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (lim &lt; (deg &lt;&lt; <span class="number">1</span>)) lim &lt;&lt;= <span class="number">1</span>, L++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim ;i++) </span><br><span class="line">		r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; deg; i++) c[i] = a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = deg; i &lt; lim; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">	NTT(b, <span class="number">1</span>); NTT(c, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">		b[i] = (<span class="number">2</span> - b[i] * c[i] % P + P) % P * b[i] % P;</span><br><span class="line">	NTT(b, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qiudoor</span><span class="params">(ll *a, <span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; i++) a[i<span class="number">-1</span>] = a[i] * i % P;</span><br><span class="line">	a[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">		inv[i] = (P - P / i * inv[P%i] % P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jinitaimei</span><span class="params">(ll *a, <span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>; i--) a[i] = a[i<span class="number">-1</span>] * inv[i] % P;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll A[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ln</span><span class="params">(ll *a, ll n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n*<span class="number">2</span>; i++) B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	put(A, n), put(B, n*2);</span></span><br><span class="line">	work(n, a, B); </span><br><span class="line">	qiudoor(a, n);</span><br><span class="line">	NTT(a, <span class="number">1</span>); NTT(B, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) a[i] = a[i] * B[i] % P;</span><br><span class="line">	NTT(a, <span class="number">-1</span>); jinitaimei(a, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> deg, ll *a, ll *b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (deg == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">void</span>) (b[<span class="number">0</span>] = <span class="number">1</span>);</span><br><span class="line">	solve(deg&gt;&gt;<span class="number">1</span>, a,  b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; deg; i++) A[i] = b[i];</span><br><span class="line">	get_ln(A, deg); </span><br><span class="line">	A[<span class="number">0</span>] = (a[<span class="number">0</span>] + <span class="number">1</span> - A[<span class="number">0</span>] + P) % P;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; deg; i++)</span><br><span class="line">		A[i] = (a[i] - A[i] + P) % P;</span><br><span class="line">	NTT(A, <span class="number">1</span>); NTT(b, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">		b[i] = b[i] * A[i] % P;</span><br><span class="line">	NTT(b, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll f[N], g[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(); init();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) f[i] = read();</span><br><span class="line">	lim = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (lim &lt;= n) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	solve(lim, f, g);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) </span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"%d "</span>, g[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</p>
</details>

<h2 id="7-多项式开根"><a href="#7-多项式开根" class="headerlink" title="7.多项式开根"></a>7.多项式开根</h2><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>, Gi = (P+<span class="number">1</span>) / G;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpw</span><span class="params">(ll di, ll mi)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (mi) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mi &amp; <span class="number">1</span>) res = res * di % P;</span><br><span class="line">		di = di * di % P;</span><br><span class="line">		mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim, L;</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a,<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">		<span class="keyword">if</span> (r[i] &gt; i) swap(a[r[i]], a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>;mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		ll wn = fpw(type == <span class="number">1</span> ? G : Gi, (P<span class="number">-1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">			ll w = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mid; j++, w = w * wn % P) &#123;</span><br><span class="line">				<span class="keyword">int</span> x = a[i + j], y = a[i + j + mid] * w % P;</span><br><span class="line">				a[i + j] = (x + y) % P;</span><br><span class="line">				a[i + j + mid] = (x - y + P) % P;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	ll inv = fpw(lim, P<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) a[i] = a[i] * inv % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[N], b[N], c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> deg, ll *a, ll *b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">		b[<span class="number">0</span>] = fpw(a[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	work((deg+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>, a, b);</span><br><span class="line">	lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (lim &lt; (deg &lt;&lt; <span class="number">1</span>)) lim &lt;&lt;= <span class="number">1</span>, L++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim ;i++) </span><br><span class="line">		r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; deg; i++) c[i] = a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = deg; i &lt; lim; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">	NTT(b, <span class="number">1</span>); NTT(c, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">		b[i] = (<span class="number">2</span> - b[i] * c[i] % P + P) % P * b[i] % P;</span><br><span class="line">	NTT(b, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qiudoor</span><span class="params">(ll *a, <span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; i++) a[i<span class="number">-1</span>] = a[i] * i % P;</span><br><span class="line">	a[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">		inv[i] = (P - P / i * inv[P%i] % P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jinitaimei</span><span class="params">(ll *a, <span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>; i--) a[i] = a[i<span class="number">-1</span>] * inv[i] % P;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll A[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ln</span><span class="params">(ll *a, ll n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n*<span class="number">2</span>; i++) B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	put(A, n), put(B, n*2);</span></span><br><span class="line">	work(n, a, B); </span><br><span class="line">	qiudoor(a, n);</span><br><span class="line">	NTT(a, <span class="number">1</span>); NTT(B, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) a[i] = a[i] * B[i] % P;</span><br><span class="line">	NTT(a, <span class="number">-1</span>); jinitaimei(a, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> deg, ll *a, ll *b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (deg == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">void</span>) (b[<span class="number">0</span>] = <span class="number">1</span>);</span><br><span class="line">	solve(deg&gt;&gt;<span class="number">1</span>, a,  b);</span><br><span class="line">	lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; deg; i++) A[i] = b[i];</span><br><span class="line">	get_ln(A, deg); </span><br><span class="line">	A[<span class="number">0</span>] = (a[<span class="number">0</span>] + <span class="number">1</span> - A[<span class="number">0</span>] + P) % P;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; deg; i++)</span><br><span class="line">		A[i] = (a[i] - A[i] + P) % P;</span><br><span class="line">	NTT(A, <span class="number">1</span>); NTT(b, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">		b[i] = b[i] * A[i] % P;</span><br><span class="line">	NTT(b, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll f[N], g[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(); init();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) f[i] = read();</span><br><span class="line">	get_ln(f, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) f[i] = f[i] * inv[<span class="number">2</span>] % P;</span><br><span class="line">	lim = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (lim &lt;= n) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	solve(lim, f, g);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) </span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"%d "</span>, g[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>

<h2 id="8-多项式除法"><a href="#8-多项式除法" class="headerlink" title="8.多项式除法"></a>8.多项式除法</h2><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Gi = (P+<span class="number">1</span>)/G;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>) + c-<span class="string">'0'</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line">ll A[N], n, lim = <span class="number">1</span>, L;</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll di,ll mi)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mi &amp; <span class="number">1</span>) ans = (ans * di) % P;</span><br><span class="line">        di = (di * di) % P;</span><br><span class="line">        mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">    <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>;mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll wn = <span class="built_in">pow</span>(type == <span class="number">1</span> ? G : Gi, (P<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; lim;j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; mid; k++, w = (w * wn) % P) &#123;</span><br><span class="line">                ll x = a[j+k], y = w * a[j+k+mid] % P;</span><br><span class="line">                a[j+k] = (x + y) % P, a[j+k+mid] = (x - y + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    ll inv = <span class="built_in">pow</span>(lim, P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">    a[i] = a[i] * inv % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll B[N], C[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> deg, ll *a, ll *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">        b[<span class="number">0</span>] = <span class="built_in">pow</span>(a[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    work((deg+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>, a, b);</span><br><span class="line">    lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt; (deg&lt;&lt;<span class="number">1</span>)) lim &lt;&lt;= <span class="number">1</span>, L++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">    r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; deg; i++) C[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) C[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(C, <span class="number">1</span>), NTT(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">    b[i] = ((ll)<span class="number">2</span> - C[i] * b[i] % P + P) % P * b[i] % P;</span><br><span class="line">    NTT(b, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll f[N], g[N], q[N], ff[N], gg[N];</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"hs.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"hs.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">0</span>; i--) read(f[i]), ff[n-i] = f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m;j &gt;= <span class="number">0</span>; j--) read(g[j]), gg[m-j] = g[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>;i &lt;= n; i++) f[i] = g[i] = <span class="number">0</span>;</span><br><span class="line">    work(n-m+<span class="number">1</span>, g, B);</span><br><span class="line">	NTT(B, <span class="number">1</span>); NTT(f, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) q[i] = f[i] * B[i] % P;</span><br><span class="line">	NTT(q, <span class="number">-1</span>);</span><br><span class="line">	reverse(q, q + n - m + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - m; i++) <span class="built_in">printf</span> (<span class="string">"%lld "</span>, q[i]);</span><br><span class="line">	lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (lim &lt;= n) lim &lt;&lt;= <span class="number">1</span>, L++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>;i &lt; lim; i++) q[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">	NTT(gg, <span class="number">1</span>); NTT(q, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) gg[i] = gg[i] * q[i] % P;</span><br><span class="line">	NTT(gg, <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; i++) <span class="built_in">printf</span> (<span class="string">"%lld "</span>, (ff[i] - gg[i] + P) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure>
## 9.拉格朗日插值

<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>) + c-<span class="string">'0'</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpw</span><span class="params">(ll x,ll mi)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (mi) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mi &amp; <span class="number">1</span>) res = res * x % P;</span><br><span class="line">		x = x * x % P;</span><br><span class="line">		mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N], y[N], n, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n), read(k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) read(x[i]), read(y[i]);</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		ll ans1 = <span class="number">1</span>, ans2 = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j == i) <span class="keyword">continue</span>;</span><br><span class="line">			ans1 = ans1 * (k - x[j]) % P;</span><br><span class="line">			ans2 = ans2 * (x[i] - x[j]) % P;</span><br><span class="line">		&#125;</span><br><span class="line">		res += y[i] * ans1 % P * fpw(ans2, P<span class="number">-2</span>) % P;</span><br><span class="line">	&#125;</span><br><span class="line">	res %= P;</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>) res += P;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>


<h2 id="10-多项式快速幂"><a href="#10-多项式快速幂" class="headerlink" title="10. 多项式快速幂"></a>10. 多项式快速幂</h2><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>, Gi = (P+<span class="number">1</span>) / G;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpw</span><span class="params">(ll di, ll mi)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mi &amp; <span class="number">1</span>) res = res * di % P;</span><br><span class="line">        di = di * di % P;</span><br><span class="line">        mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim, L;</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a,<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">        <span class="keyword">if</span> (r[i] &gt; i) swap(a[r[i]], a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>;mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll wn = fpw(type == <span class="number">1</span> ? G : Gi, (P<span class="number">-1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mid; j++, w = w * wn % P) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = a[i + j + mid] * w % P;</span><br><span class="line">                a[i + j] = (x + y) % P;</span><br><span class="line">                a[i + j + mid] = (x - y + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    ll inv = fpw(lim, P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) a[i] = a[i] * inv % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[N], b[N], c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> deg, ll *a, ll *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deg == <span class="number">1</span>) &#123;</span><br><span class="line">        b[<span class="number">0</span>] = fpw(a[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    work((deg+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>, a, b);</span><br><span class="line">    lim = <span class="number">1</span>, L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt; (deg &lt;&lt; <span class="number">1</span>)) lim &lt;&lt;= <span class="number">1</span>, L++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim ;i++) </span><br><span class="line">        r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>) &lt;&lt; (L<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; deg; i++) c[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = deg; i &lt; lim; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(b, <span class="number">1</span>); NTT(c, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">        b[i] = (<span class="number">2</span> - b[i] * c[i] % P + P) % P * b[i] % P;</span><br><span class="line">    NTT(b, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qiudoor</span><span class="params">(ll *a, <span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; i++) a[i<span class="number">-1</span>] = a[i] * i % P;</span><br><span class="line">    a[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">        inv[i] = (P - P / i * inv[P%i] % P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jinitaimei</span><span class="params">(ll *a, <span class="keyword">int</span> deg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>; i--) a[i] = a[i<span class="number">-1</span>] * inv[i] % P;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll A[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ln</span><span class="params">(ll *a, ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n*<span class="number">2</span>; i++) B[i] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//  put(A, n), put(B, n*2);</span></span><br><span class="line">    work(n, a, B); </span><br><span class="line">    qiudoor(a, n);</span><br><span class="line">    NTT(a, <span class="number">1</span>); NTT(B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) a[i] = a[i] * B[i] % P;</span><br><span class="line">    NTT(a, <span class="number">-1</span>); jinitaimei(a, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> deg, ll *a, ll *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deg == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">void</span>) (b[<span class="number">0</span>] = <span class="number">1</span>);</span><br><span class="line">    solve(deg&gt;&gt;<span class="number">1</span>, a,  b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; deg; i++) A[i] = b[i];</span><br><span class="line">    get_ln(A, deg); </span><br><span class="line">    A[<span class="number">0</span>] = (a[<span class="number">0</span>] + <span class="number">1</span> - A[<span class="number">0</span>] + P) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; deg; i++)</span><br><span class="line">        A[i] = (a[i] - A[i] + P) % P;</span><br><span class="line">    NTT(A, <span class="number">1</span>); NTT(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">        b[i] = b[i] * A[i] % P;</span><br><span class="line">    NTT(b, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; lim; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_k</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line">    <span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) &#123;</span><br><span class="line">		x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= P) x %= P;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">ll k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); init(); k = get_k();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) f[i] = read();</span><br><span class="line">    get_ln(f, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) f[i] = f[i] * k % P;</span><br><span class="line">    lim = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= n) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    solve(lim, f, g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) </span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d "</span>, g[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>


<h2 id="倍增法多项式求逆及开根（据说常数小）"><a href="#倍增法多项式求逆及开根（据说常数小）" class="headerlink" title="倍增法多项式求逆及开根（据说常数小）"></a>倍增法多项式求逆及开根（据说常数小）</h2><details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>, Gi = (P+<span class="number">1</span>) / G;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INV2 = (P+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300500</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fpw</span><span class="params">(ll di, ll mi)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (mi) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mi &amp; <span class="number">1</span>) res = res * di % P;</span><br><span class="line">		di = di * di % P;</span><br><span class="line">		mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim, r[N], n, L;</span><br><span class="line">ll f[N], g[N], A[N], C[N], D[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *a, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">    <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>;mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ll wn = fpw(type == <span class="number">1</span> ? G : Gi, (P<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; lim;j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            ll w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; mid; k++, w = (w * wn) % P) &#123;</span><br><span class="line">                ll x = a[j+k], y = w * a[j+k+mid] % P;</span><br><span class="line">                a[j+k] = (x + y) % P, a[j+k+mid] = (x - y + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    ll inv = fpw(lim, P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">    a[i] = a[i] * inv % P;</span><br><span class="line">&#125;</span><br><span class="line">ll B[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> deg, ll *a, ll *b)</span> </span>&#123;</span><br><span class="line">	b[<span class="number">0</span>] = fpw(a[<span class="number">0</span>], P<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">for</span> (len = <span class="number">1</span>;len &lt; (deg&lt;&lt;<span class="number">1</span>);len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		lim = len &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; i++) A[i] = a[i], B[i] = b[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">			r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>)?len:<span class="number">0</span>);</span><br><span class="line">		NTT(A, <span class="number">1</span>), NTT(B, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++)</span><br><span class="line">			b[i] = (<span class="number">2</span> - A[i] * B[i] % P + P) * B[i] % P;</span><br><span class="line">		NTT(b, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len;i &lt; lim; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; i++) A[i] = B[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = deg;i &lt; len; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">int</span> deg, ll *a, ll *b)</span> </span>&#123;</span><br><span class="line">	b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	ll len;</span><br><span class="line">	<span class="keyword">for</span> (len = <span class="number">1</span>;len &lt; (deg &lt;&lt; <span class="number">1</span>);len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		lim = len &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; i++) C[i] = a[i];</span><br><span class="line">		Inv(len, b, D);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) </span><br><span class="line">			r[i] = (r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i&amp;<span class="number">1</span>) ? len : <span class="number">0</span>);</span><br><span class="line">		NTT(C, <span class="number">1</span>), NTT(D, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lim; i++) C[i] = C[i] * D[i] % P;</span><br><span class="line">		NTT(C, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; i++) b[i] = (b[i] + C[i]) * INV2 % P;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len;i &lt; lim; i++) b[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) f[i] = read();</span><br><span class="line">	Sqrt(n, f, g);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) <span class="built_in">printf</span> (<span class="string">"%lld "</span>, g[i]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>





<hr>
]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>北京八十中游记</title>
    <url>/2019/12/29/%E5%8C%97%E4%BA%AC%E5%85%AB%E5%8D%81%E4%B8%AD%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="北京八十中游记"><a href="#北京八十中游记" class="headerlink" title="北京八十中游记"></a>北京八十中游记</h1><h2 id="day0"><a href="#day0" class="headerlink" title="day0:"></a>day0:</h2><p>坐了一下午的火车和地铁, 终于踉踉跄跄的来到了北京, 地面上还留着些小雪, 大家都很高兴, 因为再次逃脱了学习高考的无聊, 不过我还是有点小担心课内成绩, 怕是一回去就要使劲补课内了.</p>
<p>我妈给我装了一书包东西, 但是我并没有看是啥, 只是觉得挺沉的.到了宿舍一翻包, 惊了, 一个苹果, 七瓶酸奶, 一袋mian包, 一袋子橘子和一袋子肠. 果然了.<br><a id="more"></a></p>
<h2 id="day1"><a href="#day1" class="headerlink" title="day1:"></a>day1:</h2><p>早晨吃饭, 要了几个饺子和一个三明治, 要了我20块钱, $太^{TM}贵了$,一下子感觉石家庄的美好, 算了, 以后早上还是吃面包就酸奶吧, 比这个好多了.</p>
<p>感觉课上讲的东西不是很难, 拓展了思路, 换个环境学习有时也挺不错的. 晚上和jzp去操场跑了三圈, lhm摸了. 到现在为止没有找到能用的插座, 手机也是插在电脑上勉强度日, 只能写游记时打开了</p>
<h2 id="day2"><a href="#day2" class="headerlink" title="day2:"></a>day2:</h2><p>今天讲了一天数学, 一上午多项式, 一下午线性代数, 挂了</p>
<p>除了成都七中大神犇, 好像都挂了</p>
<h2 id="day3"><a href="#day3" class="headerlink" title="day3:"></a>day3:</h2><p>上午考试, 日常自闭, 打了T1暴力就滚了</p>
<p>晚上熬夜打CF, 写完前三道题困得不行, 后面一道题也没做出来</p>
<h2 id="day4"><a href="#day4" class="headerlink" title="day4:"></a>day4:</h2><p>数据结构属实舒适, 老师讲的也很好, 感觉长了不少知识</p>
<p>有人在颓galgame * *</p>
<h2 id="day5"><a href="#day5" class="headerlink" title="day5:"></a>day5:</h2><p>今天考试摸了, 做了做dp题(我好菜啊)</p>
<p>和lhm叫了外卖</p>
<p>晚上尝尝火锅</p>
<hr>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA12983 The Battle of Chibi</title>
    <url>/2019/12/29/UVA12983-The-Battle-of-Chibi/</url>
    <content><![CDATA[<p>第一眼能看出来是个dp</p>
<p>O($n^3$) 暴力应该很好想 dp[i][j] = $\sum_{k=1}^i [a[k] &lt; a[i]] *dp[k][j-1]$</p>
<p>发现dp[i][j] 为前面小于它的数长度为j-1的总和, 用树状数组前缀和优化一下搞成$O(n^2log_n)$</p>
<p>先离散化, dp时先枚举位置,再枚举上升序列的长度</p>
<p>树状数组要开二维哦,  打代码的时候发现dp数组可以用树状数组直接代替(小小的空间优化)</p>
<a id="more"></a>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pos, val;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;i) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (val == i.val) <span class="keyword">return</span> pos &lt; i.pos;</span><br><span class="line">		<span class="keyword">return</span> val &lt; i.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node i,node j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i.pos &lt; j.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;x;x -= low(x)) val += d[p][x];</span><br><span class="line">	<span class="keyword">return</span> val % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;x &lt;= n; x += low(x)) d[p][x] = (d[p][x] + k) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	T = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) p[i] = (node)&#123;i,<span class="built_in">read</span>()&#125;;</span><br><span class="line">		sort(p + <span class="number">1</span>,p + n + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == p[i].val) </span><br><span class="line">				p[i].val = k;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				x = p[i].val;</span><br><span class="line">				p[i].val = i;</span><br><span class="line">				k = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(p + <span class="number">1</span>,p + n + <span class="number">1</span>, cmp);</span><br><span class="line">		<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">			add(p[i].val, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= m; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> k = sum(p[i].val<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">				add(p[i].val, k, j);</span><br><span class="line">				<span class="keyword">if</span> (j == m) ans = (ans + k) % P;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">1</span>) ans += n;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"Case #%d: %lld\n"</span>, cnt, ans % P);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>数据结构优化</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>phq板子</title>
    <url>/2019/12/29/phq%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h1 id="phq板子"><a href="#phq板子" class="headerlink" title="phq板子"></a>phq板子</h1><p><a href="https://www.luogu.org/problem/P3369" target="_blank" rel="noopener">洛谷P3369</a><br><a id="more"></a></p>
<details><summary>talk is cheap, show me the code</summary>
<p>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105000</span>;</span><br><span class="line"><span class="keyword">int</span> val[N], son[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> rnd[N], tot, n;</span><br><span class="line"><span class="keyword">int</span> siz[N], root, a, p, x, y, z;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	siz[x] = siz[son[x][<span class="number">1</span>]] + siz[son[x][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	siz[++tot] = <span class="number">1</span>, rnd[tot] = rand();</span><br><span class="line">	val[tot] = x; <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">	<span class="keyword">if</span> (rnd[x] &lt; rnd[y]) &#123;</span><br><span class="line">		son[x][<span class="number">1</span>] = merge(son[x][<span class="number">1</span>], y);</span><br><span class="line">		update(x); <span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	son[y][<span class="number">0</span>] = merge(x, son[y][<span class="number">0</span>]);</span><br><span class="line">	update(y); <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!now) x = y = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (val[now] &lt;= k) x = now, split(son[x][<span class="number">1</span>], k, son[x][<span class="number">1</span>], y);</span><br><span class="line">		<span class="keyword">else</span> y = now, split(son[y][<span class="number">0</span>], k, x, son[y][<span class="number">0</span>]);</span><br><span class="line">		update(now);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k &lt;= siz[son[now][<span class="number">0</span>]]) now = son[now][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (k == siz[son[now][<span class="number">0</span>]] + <span class="number">1</span>) <span class="keyword">return</span> now;</span><br><span class="line">		<span class="keyword">else</span> k -= siz[son[now][<span class="number">0</span>]] + <span class="number">1</span>, now = son[now][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>;<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123; x = (x &lt;&lt; <span class="number">3</span>)+(x &lt;&lt; <span class="number">1</span>) + c-<span class="string">'0'</span>; c = getchar();&#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	read(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		read(p), read(a);</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="number">1</span>) &#123;</span><br><span class="line">			split(root, a, x, y);</span><br><span class="line">			root = merge(merge(x, build(a)), y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">2</span>) &#123;</span><br><span class="line">			split(root, a, x, y);</span><br><span class="line">			split(x, a<span class="number">-1</span>, x, z);</span><br><span class="line">			z = merge(son[z][<span class="number">0</span>], son[z][<span class="number">1</span>]);</span><br><span class="line">			root = merge(merge(x, z), y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">3</span>) &#123;</span><br><span class="line">			split(root, a<span class="number">-1</span>, x, y);</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, siz[x] + <span class="number">1</span>);</span><br><span class="line">			root = merge(x, y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">4</span>) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, val[kth(root, a)]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">5</span>) &#123;</span><br><span class="line">			split(root, a<span class="number">-1</span>, x, y);</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, val[kth(x, siz[x])]);</span><br><span class="line">			root = merge(x, y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			split(root, a, x, y);</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, val[kth(y, <span class="number">1</span>)]);</span><br><span class="line">			root = merge(x, y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>


<p><a href="https://www.luogu.org/problem/P3391" target="_blank" rel="noopener">洛谷P3391</a></p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100050</span>;</span><br><span class="line"><span class="keyword">int</span> rnd[N], siz[N];</span><br><span class="line"><span class="keyword">int</span> cnt, n, l, r;</span><br><span class="line"><span class="keyword">int</span> tag[N], son[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> val[N], root, x, y, z;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	siz[++cnt] = <span class="number">1</span>, val[cnt] = x;</span><br><span class="line">	rnd[cnt] = rand(); <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	siz[x] = siz[son[x][<span class="number">1</span>]] + siz[son[x][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tag[x]) &#123;</span><br><span class="line">		swap(son[x][<span class="number">0</span>], son[x][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (son[x][<span class="number">0</span>]) tag[son[x][<span class="number">0</span>]] ^= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (son[x][<span class="number">1</span>]) tag[son[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">		tag[x] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!now) x = y = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		spread(now);</span><br><span class="line">		<span class="keyword">if</span> (siz[son[now][<span class="number">0</span>]] &lt; k) x = now, split(son[x][<span class="number">1</span>], k - siz[son[now][<span class="number">0</span>]] - <span class="number">1</span>, son[x][<span class="number">1</span>], y);</span><br><span class="line">		<span class="keyword">else</span> y = now, split(son[y][<span class="number">0</span>], k, x, son[y][<span class="number">0</span>]);</span><br><span class="line">		update(now);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">	<span class="keyword">if</span> (rnd[x] &lt; rnd[y]) &#123;</span><br><span class="line">		spread(x);</span><br><span class="line">		son[x][<span class="number">1</span>] = merge(son[x][<span class="number">1</span>], y);</span><br><span class="line">		update(x); <span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	spread(y);</span><br><span class="line">	son[y][<span class="number">0</span>] = merge(x, son[y][<span class="number">0</span>]);</span><br><span class="line">	update(y); <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>;<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123; x = (x &lt;&lt; <span class="number">3</span>)+(x &lt;&lt; <span class="number">1</span>) + c-<span class="string">'0'</span>; c = getchar();&#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">res</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">	spread(x);</span><br><span class="line">	res(son[x][<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d "</span>, val[x]);</span><br><span class="line">	res(son[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n), read(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) root = merge(root, build(i));</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		read(l), read(r);</span><br><span class="line">		split(root, l - <span class="number">1</span>, x, y);</span><br><span class="line">		split(y, r - l+ <span class="number">1</span>, y, z);</span><br><span class="line">		tag[y] ^= <span class="number">1</span>;</span><br><span class="line">		root = merge(merge(x, y), z);</span><br><span class="line">	&#125;</span><br><span class="line">	res(root);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>



<hr>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P5369 [PKUSC2018]最大前缀和</title>
    <url>/2019/12/29/P5369-PKUSC2018-%E6%9C%80%E5%A4%A7%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><h4 id="P5369"><a href="#P5369" class="headerlink" title="P5369"></a><a href="https://www.luogu.org/problem/P5369" target="_blank" rel="noopener">P5369</a></h4><p>题意:求所有排列下的最大前缀和之和</p>
<p>一步转化: 求最大前缀和的前缀由数集S组成的方案数, 统计答案时直接乘上sum(S)即可</p>
<p>考虑最大前缀和的性质:</p>
<p>设最大前缀和为sum[i]</p>
<ol>
<li>到i的后缀均为正数</li>
<li>i后的前缀均为负数</li>
</ol>
<p>令sum[i] = 集合 i 内所有数的和。</p>
<p>令f[i]  = 集合 i内的数组成的排列，最大前缀和 = sum[i]的方案数。</p>
<p>令g[i] = 集合 i内的数组成的排列，所有的最大前缀和都 &lt; 0 的方案数。<br><a id="more"></a></p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1050050</span>], g[<span class="number">1050050</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">1050050</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">to</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n; <span class="keyword">int</span> all = to(n) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a[i], f[to(i<span class="number">-1</span>)] = <span class="number">1</span>, sum[to(i<span class="number">-1</span>)] = a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= all; i++) </span><br><span class="line">			sum[i] = sum[(i &amp; -i)] + sum[i ^ (i &amp; -i)];</span><br><span class="line">	g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; all; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sum[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; j++) </span><br><span class="line">				<span class="keyword">if</span> (!(i &amp; to(j<span class="number">-1</span>))) </span><br><span class="line">					f[i | to(j<span class="number">-1</span>)] = ((<span class="keyword">long</span> <span class="keyword">long</span>)f[i] + f[i | to(j<span class="number">-1</span>)]) % P;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; j++) </span><br><span class="line">				<span class="keyword">if</span> (i &amp; (to(j<span class="number">-1</span>))) </span><br><span class="line">					g[i] = ((<span class="keyword">long</span> <span class="keyword">long</span>)g[i] + g[i ^ to(j<span class="number">-1</span>)]) % P;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= all; i++)</span><br><span class="line">		ans = (ans + (<span class="keyword">long</span> <span class="keyword">long</span>)f[i] * g[all^i] % P * sum[i] % P) % P;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (ans % P + P) % P &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>


<hr>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P3943 星空</title>
    <url>/2019/12/29/P3943-%E6%98%9F%E7%A9%BA/</url>
    <content><![CDATA[<h2 id="P3943"><a href="#P3943" class="headerlink" title="P3943"></a><a href="&quot;https://www.luogu.org/problem/P3943&quot;">P3943</a></h2><h3 id="思维好题"><a href="#思维好题" class="headerlink" title="思维好题"></a>思维好题</h3><p>接下来, 您将看到 :</p>
<ul>
<li>差分(??!)</li>
<li>bfs</li>
<li>状压dp</li>
</ul>
<a id="more"></a>
<h3 id="第一波操作-差分"><a href="#第一波操作-差分" class="headerlink" title="第一波操作(差分):"></a>第一波操作(差分):</h3><p>d[i] = a[i] ^ a[i-1]</p>
<p>例子: 10011100 (0表示不亮, 1为亮了) 它的”差分”数组为 11010010</p>
<p>吃瓜群众: 为什么要这么表示</p>
<p>let’s 模拟 it</p>
<p>原状态 : 10011100 -&gt; 11010010 将第四盏到第六盏搞一下 10000000 -&gt; 11000000</p>
<p>fa♂现了没有, 差分数组位置4, 7改变, 因为异或使4到6同时改变, 他们相邻两个异或值不会改变</p>
<p>而3和4, 6和7中有一个值改变, 那么他们异或值也会改变</p>
<p>同样的, 如果操作第四盏到第七盏, 发现差分数组位置4的1移到了位置8(汝可模拟得知)</p>
<p>所以我们要求出所有的1,移动最少几次和另一个1配对</p>
<h3 id="第二波操作-bfs"><a href="#第二波操作-bfs" class="headerlink" title="第二波操作(bfs):"></a>第二波操作(bfs):</h3><p>预处理出每一个1到其他1的距离, bfs就行啦</p>
<h3 id="第三波操作-状压dp"><a href="#第三波操作-状压dp" class="headerlink" title="第三波操作(状压dp):"></a>第三波操作(状压dp):</h3><p>设计状态S, f[S]表示消除点集S至少要操作多少次</p>
<p>f[S] = min(f[S], f[S-‘两个点’] + 两点相消要走多少次);</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40050</span>;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">70</span>], n, m, k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50</span>], f[N];</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">50</span>], g[<span class="number">1005000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">to</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k; i++) </span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	sort(a + <span class="number">1</span>,a + k + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	pos[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= k; i++) </span><br><span class="line">	<span class="keyword">if</span> (a[i] != a[i<span class="number">-1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">		pos[++cnt] = a[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		pos[++cnt] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	pos[++cnt] = a[k]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	q.push(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (q.size()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = x + b[i];</span><br><span class="line">			<span class="keyword">if</span> (y &lt;= n &amp;&amp; f[y] &gt; n) &#123;</span><br><span class="line">				f[y] = f[x] + <span class="number">1</span>;</span><br><span class="line">				q.push(y);</span><br><span class="line">			&#125;</span><br><span class="line">			y = x - b[i];</span><br><span class="line">			<span class="keyword">if</span> (y &gt; <span class="number">0</span> &amp;&amp; f[y] &gt; n) &#123;</span><br><span class="line">				f[y] = f[x] + <span class="number">1</span>;</span><br><span class="line">				q.push(y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		</span><br><span class="line">	<span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">	g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">1</span> &lt;&lt; cnt; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt; j++) </span><br><span class="line">			<span class="keyword">if</span> (i &amp; to(j<span class="number">-1</span>)) tmp++;</span><br><span class="line">		<span class="keyword">if</span> (tmp &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt; j++) </span><br><span class="line">			<span class="keyword">if</span> (i &amp; to(j<span class="number">-1</span>))</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>;k &lt;= cnt; k++) </span><br><span class="line">				<span class="keyword">if</span> (i &amp; to(k<span class="number">-1</span>)) </span><br><span class="line">					g[i] = min(g[i], g[i^to(k<span class="number">-1</span>)^to(j<span class="number">-1</span>)] + f[pos[k]-pos[j]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; g[(<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>




<hr>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>思想</tag>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title>P3515 [POI2011]Lightning Conductor</title>
    <url>/2019/12/29/P3515-POI2011-Lightning-Conductor/</url>
    <content><![CDATA[<p>首先进行一步转化</p>
<p>$a_j \leq a_i + q - sqrt(abs(i - j))$</p>
<p>$a_i + q \geq a_j + sqrt(abs(i-j))$</p>
<p>  即 $q = max (a_j + sqrt(abs(i-j))) - a_i $<br><a id="more"></a></p>
<p>我们对$i \geq j 和 j &gt; i$ 分类讨论, 其实解决一种情况后将序列翻转再做一遍即可</p>
<p>有一种O($n^2$)的dp暴力应该不难想到</p>
<p>那么我们现在思考如何以比较优秀的时间复杂度解决</p>
<p>这里涉及到决策单调性</p>
<p>简单的说, 对于i来说, 它的答案来源是另一点j,</p>
<p>那么所有答案来源排成的序列$j_1,j_2,j_3,\cdots j_n$ 具有单调性</p>
<p>比如: 1112255566666666678888</p>
<p>那么我们可以考虑对于每一个i, 它可以成为哪一段区间的答案</p>
<p>即一个三元组(l, r, i) 对应i控制l到r</p>
<p>可以二分+栈(或队列)处理</p>
<p> 二分i和栈顶答案相等临界, 若临界小于l则弹栈重复操作</p>
<p>否则将新的(l, r, i) 压倒栈中</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500080</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll l, r, x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;node&gt; q;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125; <span class="comment">//快读</span></span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ans[N], a[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x,ll y,ll k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[x] + <span class="built_in">sqrt</span>(k - x) &gt; a[y] + <span class="built_in">sqrt</span>(k - y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	node k = (node)&#123;<span class="number">1</span>, n, <span class="number">1</span>&#125;; </span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; a[k.x]) <span class="keyword">continue</span>; <span class="comment">//剪枝, 如果满足则它一定不会有贡献</span></span><br><span class="line">		ll l = i, r = n, mid;</span><br><span class="line">		<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">			mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (check(k.x, i, mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="comment">//二分</span></span><br><span class="line">		<span class="keyword">if</span> (l == n + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (l &lt;= k.l) &#123;</span><br><span class="line">			k = q.front();</span><br><span class="line">			q.pop_front();</span><br><span class="line">			i--;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;<span class="comment">//弹栈</span></span><br><span class="line">		k.r = r;</span><br><span class="line">		q.push_front(k);</span><br><span class="line">		k = (node)&#123;l, n, i&#125;; <span class="comment">//压栈</span></span><br><span class="line">	&#125;</span><br><span class="line">	q.push_front(k);</span><br><span class="line">	k = q.back();</span><br><span class="line">	q.pop_back();</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k.r &lt; i) &#123;</span><br><span class="line">			k = q.back();</span><br><span class="line">			q.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">		ans[i] = <span class="built_in">max</span>(ans[i], a[k.x] + <span class="built_in">sqrt</span>(i - k.x)); <span class="comment">//要做两次,所以取max</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">		a[i] = <span class="built_in">read</span>(), ans[i] = a[i];</span><br><span class="line">	work();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;&lt; <span class="number">1</span> &lt;= n; j++) </span><br><span class="line">	swap(a[j], a[n-j+<span class="number">1</span>]), swap(ans[j], ans[n-j+<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//翻转</span></span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()) q.pop_front();</span><br><span class="line">	work();</span><br><span class="line">	<span class="comment">///*</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, <span class="keyword">int</span>(<span class="built_in">ceil</span>(ans[i]) - a[i]));</span><br><span class="line">		<span class="comment">//*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>





<hr>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>决策单调性</category>
      </categories>
      <tags>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title>P3396 哈希冲突</title>
    <url>/2019/12/29/P3396-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<h4 id="这个套路还是蛮常见的"><a href="#这个套路还是蛮常见的" class="headerlink" title="这个套路还是蛮常见的"></a>这个套路还是蛮常见的</h4><p>思路: 将操作分为两类, 大于$\sqrt{n}$ 的, 和小于它的</p>
<p>为什么要这么干</p>
<p>考虑暴力 , 每次修改$O(1)$ , 每次查询$O(n)$ </p>
<p>那么它的复杂度是$O(n^2)$ 的</p>
<p>观察发现, 修改的复杂度远小于查询, 导致复杂度不平衡</p>
<p>考虑在修改时预处理以降低查询复杂度</p>
<p>修改时处理将x膜1 ~ $\sqrt{n}$ 加上a[x], cnt[x] += a[x],  $O(\sqrt{n})$ </p>
<p>查询时, 如果x &lt; $\sqrt{n}$ , 直接输出 mod[x][y%x]  , 否则 暴力枚举 , 复杂度$O(\sqrt{n})$ </p>
<p>总复杂度$O(\sqrt{n})$<br><a id="more"></a></p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> siz;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt[<span class="number">500000</span>], mod[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= siz; i++) mod[i][x % i] += k;</span><br><span class="line">	cnt[x] += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">	siz = <span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		a[i] = <span class="built_in">read</span>();</span><br><span class="line">		add(i, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%s"</span>, s);</span><br><span class="line">		<span class="keyword">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">			add(x, -a[x]);</span><br><span class="line">			a[x] = y;</span><br><span class="line">			add(x, y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			y %= x;</span><br><span class="line">			<span class="keyword">if</span> (x &lt;= siz) <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, mod[x][y]);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = y;i &lt;= n; i += x) val += cnt[i];</span><br><span class="line">				<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, val);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>






<hr>
]]></content>
      <categories>
        <category>技巧</category>
        <category>数据分块</category>
      </categories>
      <tags>
        <tag>数据分块</tag>
      </tags>
  </entry>
  <entry>
    <title>P3295 [SCOI2016]萌萌哒</title>
    <url>/2019/12/29/P3295-SCOI2016-%E8%90%8C%E8%90%8C%E5%93%92/</url>
    <content><![CDATA[<h4 id="P1502"><a href="#P1502" class="headerlink" title="P1502"></a><a href="&quot;https://www.luogu.org/problem/P1502&quot;">P1502</a></h4><h2 id="st表-并查集"><a href="#st表-并查集" class="headerlink" title="st表 + 并查集"></a>st表 + 并查集</h2><p>回顾:<strong>st表</strong></p>
<p>f[i][j] 为序列中 i ~ i + $2^j$ - 1中的最大(小)值</p>
<p>预处理 f[i][0] = $a_i$ , f[i][j+1] = max(f[i][j], f[i + (1 &lt;&lt; j)][j]) </p>
<p>查询 : 对于区间[l, r], 我们将它分解为[l, $2^k$], 和[r - $2^k$ + 1, r]两个区间, 它们可能会有重叠, 但取max并不会影响区间最值<br><a id="more"></a></p>
<p>回到本题: </p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qosysovx.png" alt=""></p>
<p>如图, 由题意将[l1, r1](黑), [l2, r2](绿)合并</p>
<p>应用st表思想</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7xf7k8g6.png" alt=""></p>
<p>可以看成将两个红色区间合并, 两个橙色区间合并, 有重复并不影响答案, 因为他只是维护了等量关系</p>
<p>合并可以利用并查集维护</p>
<p>最后枚举从大到小枚举len, 将大区间的等量关系下放到两个小区间上, 最后统计答案即可</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100050</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[x][y] == x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> f[x][y] = find(f[x][y], y);</span><br><span class="line">&#125; <span class="comment">//找爹</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx = find(f[x][len], len), fy = find(f[y][len], len);</span><br><span class="line">	f[f[fx][len]][len] = fy;</span><br><span class="line">&#125; <span class="comment">//合并</span></span><br><span class="line"><span class="keyword">int</span> lo[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read(), m = read();</span><br><span class="line">	lo[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) lo[i] = lo[i/<span class="number">2</span>]+<span class="number">1</span>; <span class="comment">// 预处理log2(k)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">21</span>; j++) </span><br><span class="line">			f[i][j] = i;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="keyword">int</span> l1 = read(), r1 = read(), l2 = read(), r2 = read();</span><br><span class="line">		<span class="keyword">int</span> len = lo[r1 - l1 + <span class="number">1</span>];</span><br><span class="line">		merge(l1, l2, len); <span class="comment">//分成两个小区间</span></span><br><span class="line">		l1 = r1 - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>, l2 = r2 - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>;</span><br><span class="line">		merge(l1, l2, len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">21</span>;len &gt;= <span class="number">1</span>; len--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i + (<span class="number">1</span> &lt;&lt; len) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> fa = find(i, len);</span><br><span class="line">			<span class="keyword">if</span> (fa != i) &#123;</span><br><span class="line">				merge(i, fa, len<span class="number">-1</span>); <span class="comment">//大区间分裂成两个小区间</span></span><br><span class="line">				merge(i + (<span class="number">1</span> &lt;&lt; (len<span class="number">-1</span>)), fa + (<span class="number">1</span> &lt;&lt; (len<span class="number">-1</span>)), len - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f[i][<span class="number">0</span>] == i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ans == <span class="number">0</span>) ans = <span class="number">9</span>;</span><br><span class="line">			<span class="keyword">else</span> ans = ans * <span class="number">10</span> % P;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans % P &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>




<hr>
]]></content>
      <categories>
        <category>基础算法</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>st表</tag>
      </tags>
  </entry>
  <entry>
    <title>P3165 [CQOI2014]排序机械臂</title>
    <url>/2019/12/29/P3165-CQOI2014-%E6%8E%92%E5%BA%8F%E6%9C%BA%E6%A2%B0%E8%87%82/</url>
    <content><![CDATA[<h2 id="FHQ-Treap解法"><a href="#FHQ-Treap解法" class="headerlink" title="FHQ Treap解法"></a>FHQ Treap解法</h2><p>这道题当然用好写的fhq解决啦(<del>其实是不会splay</del>)</p>
<p>一开始, 感觉无法同时权值分裂又排名分裂</p>
<p>所以我按排名分裂, 维护子树最小值, 设计一个类似求第k大的函数,  找出区间最小值的位置</p>
<p>详见代码, 还是很好懂的(除get_rk函数, 其他部分和文艺平衡树一样)</p>
<a id="more"></a>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c);c=getchar()) <span class="keyword">if</span> (c==<span class="string">'-'</span>) f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c);c=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span> (f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100050</span>;</span><br><span class="line"><span class="keyword">int</span> tag[N], siz[N];</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">2</span>], rnd[N];</span><br><span class="line"><span class="keyword">int</span> val[N], mn[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> pos, num;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;i) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (num != i.num) <span class="keyword">return</span> num &lt; i.num;</span><br><span class="line">		<span class="keyword">return</span> pos &lt; i.pos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rt, x, y, z;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	val[++tot] = x, mn[tot] = x, siz[tot] = <span class="number">1</span>;</span><br><span class="line">	rnd[tot] = rand(); <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mn</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x &lt; y ? x : y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	siz[x] = siz[son[x][<span class="number">0</span>]] + siz[son[x][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">	mn[x] = val[x]; </span><br><span class="line">	<span class="keyword">if</span> (son[x][<span class="number">0</span>]) mn[x] = Mn(mn[son[x][<span class="number">0</span>]], mn[x]);</span><br><span class="line">	<span class="keyword">if</span> (son[x][<span class="number">1</span>]) mn[x] = Mn(mn[son[x][<span class="number">1</span>]], mn[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tag[x]) <span class="keyword">return</span>;</span><br><span class="line">	swap(son[x][<span class="number">0</span>], son[x][<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (son[x][<span class="number">0</span>]) tag[son[x][<span class="number">0</span>]] ^= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (son[x][<span class="number">1</span>]) tag[son[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">	tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x | y;</span><br><span class="line">	<span class="keyword">if</span> (rnd[x] &lt; rnd[y]) &#123;</span><br><span class="line">		spread(x);</span><br><span class="line">		son[x][<span class="number">1</span>] = merge(son[x][<span class="number">1</span>], y);</span><br><span class="line">		update(x); <span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	spread(y);</span><br><span class="line">	son[y][<span class="number">0</span>] = merge(x, son[y][<span class="number">0</span>]);</span><br><span class="line">	update(y); <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!now) &#123;</span><br><span class="line">		x = y = <span class="number">0</span>; <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	spread(now);</span><br><span class="line">	<span class="keyword">if</span> (siz[son[now][<span class="number">0</span>]] &lt; k) &#123;</span><br><span class="line">		x = now;</span><br><span class="line">		split(son[x][<span class="number">1</span>], k - siz[son[x][<span class="number">0</span>]] - <span class="number">1</span>, son[x][<span class="number">1</span>], y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> y = now, split(son[y][<span class="number">0</span>], k, x, son[y][<span class="number">0</span>]);</span><br><span class="line">	update(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出最小值的排名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rk</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">1</span>; <span class="comment">//初始排名</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		spread(x);</span><br><span class="line">		<span class="keyword">if</span> (son[x][<span class="number">0</span>] &amp;&amp; mn[son[x][<span class="number">0</span>]] == mn[x]) x = son[x][<span class="number">0</span>]; <span class="comment">//在左子树</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (son[x][<span class="number">1</span>] &amp;&amp; mn[son[x][<span class="number">1</span>]] == mn[x]) k += siz[son[x][<span class="number">0</span>]] + <span class="number">1</span>, x = son[x][<span class="number">1</span>]; </span><br><span class="line">        <span class="comment">//在右子树</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> k + siz[son[x][<span class="number">0</span>]]; <span class="comment">//在当前节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		read(a[i].num); a[i].pos = i;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">	v[a[i].pos] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">		rt = merge(rt, build(v[i]));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = get_rk(rt);</span><br><span class="line">		split(rt, k, x, y);</span><br><span class="line">		split(x, k<span class="number">-1</span>, x, z);</span><br><span class="line">		tag[x] ^= <span class="number">1</span>;</span><br><span class="line">		rt = merge(x, y);</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"%d "</span>, k + i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1 8 6 5 3 5 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


</p>
</details>




<hr>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P2585 [ZJOI2006]三色二叉树</title>
    <url>/2019/12/29/P2585-ZJOI2006-%E4%B8%89%E8%89%B2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>介绍一个无建树做法</p>
<h4 id="个人认为我的代码比较易懂-简直不需要注释"><a href="#个人认为我的代码比较易懂-简直不需要注释" class="headerlink" title="个人认为我的代码比较易懂(简直不需要注释)"></a>个人认为我的代码比较易懂(<del>简直不需要注释</del>)</h4><p>定义dp[x][0/1/2] 分别为x节点染绿 /红 /蓝 情况下子树中最多有几个点被染成绿色</p>
<p>类似的 f[x][0/1/2] 为最少有几个点</p>
<a id="more"></a>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500050</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">4</span>], f[N][<span class="number">4</span>], cnt;</span><br><span class="line"><span class="keyword">int</span> ans1 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s[x] == <span class="string">'0'</span>) &#123;<span class="comment">//叶节点</span></span><br><span class="line">		f[x][<span class="number">0</span>] = dp[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(++cnt);</span><br><span class="line">    <span class="comment">//左儿子编号为x+1</span></span><br><span class="line">	<span class="keyword">if</span> (s[x] == <span class="string">'1'</span>) &#123; <span class="comment">//一个儿子</span></span><br><span class="line">		dp[x][<span class="number">0</span>] = <span class="built_in">max</span>(dp[x+<span class="number">1</span>][<span class="number">1</span>], dp[x+<span class="number">1</span>][<span class="number">2</span>])+<span class="number">1</span>;</span><br><span class="line">		dp[x][<span class="number">1</span>] = <span class="built_in">max</span>(dp[x+<span class="number">1</span>][<span class="number">0</span>], dp[x+<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">		dp[x][<span class="number">2</span>] = <span class="built_in">max</span>(dp[x+<span class="number">1</span>][<span class="number">0</span>], dp[x+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        	<span class="comment">//儿子染另外一种颜色</span></span><br><span class="line">		<span class="comment">// 上方代码完全是复制一遍到下面</span></span><br><span class="line">		f[x][<span class="number">0</span>] = <span class="built_in">min</span>(f[x+<span class="number">1</span>][<span class="number">1</span>], f[x+<span class="number">1</span>][<span class="number">2</span>])+<span class="number">1</span>;</span><br><span class="line">		f[x][<span class="number">1</span>] = <span class="built_in">min</span>(f[x+<span class="number">1</span>][<span class="number">0</span>], f[x+<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">		f[x][<span class="number">2</span>] = <span class="built_in">min</span>(f[x+<span class="number">1</span>][<span class="number">0</span>], f[x+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//右儿子编号为k</span></span><br><span class="line">		<span class="keyword">int</span> k = ++cnt;</span><br><span class="line">		dfs(k);</span><br><span class="line">		dp[x][<span class="number">0</span>] = <span class="built_in">max</span>(dp[x+<span class="number">1</span>][<span class="number">1</span>] + dp[k][<span class="number">2</span>], dp[x+<span class="number">1</span>][<span class="number">2</span>] + dp[k][<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">		dp[x][<span class="number">1</span>] = <span class="built_in">max</span>(dp[x+<span class="number">1</span>][<span class="number">0</span>] + dp[k][<span class="number">2</span>], dp[x+<span class="number">1</span>][<span class="number">2</span>] + dp[k][<span class="number">0</span>]);</span><br><span class="line">		dp[x][<span class="number">2</span>] = <span class="built_in">max</span>(dp[x+<span class="number">1</span>][<span class="number">0</span>] + dp[k][<span class="number">1</span>], dp[x+<span class="number">1</span>][<span class="number">1</span>] + dp[k][<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line">		f[x][<span class="number">0</span>] = <span class="built_in">min</span>(f[x+<span class="number">1</span>][<span class="number">1</span>] + f[k][<span class="number">2</span>], f[x+<span class="number">1</span>][<span class="number">2</span>] + f[k][<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">		f[x][<span class="number">1</span>] = <span class="built_in">min</span>(f[x+<span class="number">1</span>][<span class="number">0</span>] + f[k][<span class="number">2</span>], f[x+<span class="number">1</span>][<span class="number">2</span>] + f[k][<span class="number">0</span>]);</span><br><span class="line">		f[x][<span class="number">2</span>] = <span class="built_in">min</span>(f[x+<span class="number">1</span>][<span class="number">0</span>] + f[k][<span class="number">1</span>], f[x+<span class="number">1</span>][<span class="number">1</span>] + f[k][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	ans1 = <span class="built_in">max</span>(ans1, dp[x][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">	dfs(++cnt);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans1 &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">0</span>], <span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">1</span>], f[<span class="number">1</span>][<span class="number">2</span>])) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>




<hr>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P2486 [SDOI2011]染色</title>
    <url>/2019/12/29/P2486-SDOI2011-%E6%9F%93%E8%89%B2/</url>
    <content><![CDATA[<h3 id="P2486"><a href="#P2486" class="headerlink" title="P2486"></a><a href="https://www.luogu.org/problem/P2486" target="_blank" rel="noopener">P2486</a></h3><p>很经典的题~</p>
<p>思路: 线段树染色+”熟练”剖分(某些出题人总是喜欢把序列上的题加个树链剖分搞到树上去)</p>
<p>先想一想序列上怎么做吧<br><a id="more"></a></p>
<p><del>线段树是个好东西</del></p>
<p>每个节点维护三个信息: ls: 左端点的颜色    rs: 右端点的颜色 cnt: [l, r] 中共有几个颜色段</p>
<p>合并? </p>
<p>fa.cnt = son1.cnt + son2.cnt - [son1.rs == son2.ls]</p>
<p>fa.ls = son1.ls ,       fa.rs =  son2.rs</p>
<p>爹的左端点颜色就是左儿子的左端点颜色, 右端点亦然</p>
<p>如果左儿子与右儿子相接的颜色相同, 那么等于左儿子块数加右儿子块数-1(中间两个块会合成一个)</p>
<p>否则直接加就行啦</p>
<p>修改时要打<strong>标记</strong> 记录有没有被覆盖</p>
<h4 id="回到树上问题时要特别注意的是询问"><a href="#回到树上问题时要特别注意的是询问" class="headerlink" title="回到树上问题时要特别注意的是询问"></a>回到树上问题时要特别注意的是询问</h4><p>因为询问时有swap的操作, 将k记录x,y的顺序, 即相当于(x, y) 还是(y, x)</p>
<p>如果是(y, x), 最后还要反回来才能进行合并</p>
<p>在跳重链时, 总是将链接在它的左边, 最后将a左右儿子反一下再与b合并即可</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105000</span>*<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N], id[N], siz[N];</span><br><span class="line"><span class="keyword">int</span> num, dep[N], son[N];</span><br><span class="line"><span class="keyword">int</span> w[N], wt[N], Top[N];</span><br><span class="line"><span class="keyword">int</span> h[N], ne[N], to[N];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	ne[++tot] = h[x], h[x] = tot;</span><br><span class="line">	to[tot] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	fa[x] = f;</span><br><span class="line">	siz[x] = <span class="number">1</span>, dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i ;i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = to[i];</span><br><span class="line">		<span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">		dfs1(y, x);</span><br><span class="line">		siz[x] += siz[y];</span><br><span class="line">		<span class="keyword">if</span> (siz[y] &gt; siz[son[x]]) son[x] = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">	id[x] = ++num; wt[num] = w[x];</span><br><span class="line">	Top[x] = topf;</span><br><span class="line">	<span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">	dfs2(son[x], topf);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = to[i];</span><br><span class="line">		<span class="keyword">if</span> (y == fa[x] || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(y, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N], cnt[N], ls[N], rs[N];</span><br><span class="line"><span class="keyword">int</span> tag[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p1 p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p2 p &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cnt, ls, rs;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(node &amp;fa,node i,node j)</span> </span>&#123;</span><br><span class="line">	fa.cnt = i.cnt + j.cnt - (i.rs == j.ls);</span><br><span class="line">	fa.ls = i.ls, fa.rs = j.rs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	L[p] = l, R[p] = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		cnt[p] = <span class="number">1</span>, ls[p] = rs[p] = wt[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(l, mid, p1);</span><br><span class="line">	build(mid+<span class="number">1</span>, r, p2);</span><br><span class="line">	cnt[p] = cnt[p1] + cnt[p2] - (rs[p1] == ls[p2]);</span><br><span class="line">	ls[p] = ls[p1], rs[p] = rs[p2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tag[p]) &#123;</span><br><span class="line">		cnt[p1] = cnt[p2] = <span class="number">1</span>;</span><br><span class="line">		tag[p1] = tag[p2] = tag[p];</span><br><span class="line">		ls[p1] = ls[p2] = rs[p1] = rs[p2] = tag[p];</span><br><span class="line">		tag[p] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L[p] &gt;= l &amp;&amp; R[p] &lt;= r) &#123;</span><br><span class="line">		cnt[p] = <span class="number">1</span>, tag[p] = c;</span><br><span class="line">		ls[p] = rs[p] = c;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	spread(p);</span><br><span class="line">	<span class="keyword">if</span> (R[p1] &gt;= l) change(l, r, p1, c);</span><br><span class="line">	<span class="keyword">if</span> (L[p2] &lt;= r) change(l, r, p2, c);</span><br><span class="line">	cnt[p] = cnt[p1] + cnt[p2] - (rs[p1] == ls[p2]);</span><br><span class="line">	ls[p] = ls[p1], rs[p] = rs[p2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L[p] &gt;= l &amp;&amp; R[p] &lt;= r) <span class="keyword">return</span> (node)&#123;cnt[p], ls[p], rs[p]&#125;;</span><br><span class="line">	spread(p);</span><br><span class="line">	node i;</span><br><span class="line">	<span class="keyword">if</span> (R[p1] &lt; l) <span class="keyword">return</span> ask(l, r, p2);</span><br><span class="line">	<span class="keyword">if</span> (L[p2] &gt; r) <span class="keyword">return</span> ask(l, r, p1);</span><br><span class="line">	update(i, ask(l, r, p1), ask(l, r, p2));</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_e</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (Top[x] != Top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[Top[x]] &lt; dep[Top[y]]) swap(x, y);</span><br><span class="line">		change(id[Top[x]], id[x], <span class="number">1</span>, c);</span><br><span class="line">		x = fa[Top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">	change(id[y], id[x], <span class="number">1</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	node ans, a, b;</span><br><span class="line">	ans = a = b = (node)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (Top[x] != Top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[Top[x]] &lt; dep[Top[y]]) swap(x, y), swap(a, b), k ^= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (a.cnt == <span class="number">0</span>) a = ask(id[Top[x]], id[x], <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> update(a, ask(id[Top[x]], id[x], <span class="number">1</span>), a);</span><br><span class="line">		x = fa[Top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y), swap(a, b);</span><br><span class="line">	<span class="keyword">if</span> (a.cnt == <span class="number">0</span>) a = ask(id[y], id[x], <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> update(a, ask(id[y], id[x], <span class="number">1</span>), a);</span><br><span class="line">	<span class="keyword">if</span> (b.cnt == <span class="number">0</span>) <span class="keyword">return</span> a.cnt;</span><br><span class="line">	<span class="keyword">if</span> (a.cnt == <span class="number">0</span>) <span class="keyword">return</span> b.cnt;</span><br><span class="line">	<span class="keyword">if</span> (!k) swap(a, b); <span class="comment">// 将a, b恢复正常顺序</span></span><br><span class="line">	swap(a.ls, a.rs); <span class="comment">//将a左右儿子换位</span></span><br><span class="line">	update(ans, a, b);</span><br><span class="line">	<span class="keyword">return</span> ans.cnt;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5</span>];</span><br><span class="line">ll a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">for</span> (;!<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (;<span class="built_in">isdigit</span>(c); c = getchar()) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n), read(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) read(w[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">		read(a), read(b);</span><br><span class="line">		add(a, b); add(b, a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs1(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">	dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">			read(a), read(b), read(c);</span><br><span class="line">			change_e(a, b, c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			read(a), read(b);</span><br><span class="line">			<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, sum(a, b));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>





<hr>
]]></content>
      <categories>
        <category>树上问题</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1129 [ZJOI2007]矩阵游戏</title>
    <url>/2019/12/29/P1129-ZJOI2007-%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><p><a href="&quot;https://www.luogu.org/problem/P1129&quot;">P1129</a></p>
<p>这个题还是有一定套路的</p>
<p>将黑色格子所在的行和列连边, 跑一边最大匹配, 如果是完美匹配即可(所有点都是匹配点)<br><a id="more"></a></p>
<p>why?</p>
<p>在完美匹配的情况下</p>
<p>假如 列1 -&gt; 行5 , 列4 -&gt; 行1 (-&gt;表示匹配) </p>
<p>我们则可以将行5和行1换一下位置, 这样交换 列不会受到影响,  匹配变为列1 -&gt; 行1, 列4 -&gt; 行5</p>
<p>同理, 列2, 列3, 列4也可以通过和别人交换来搞到自己的菜</p>
<p>证毕</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40005</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], ne[N * <span class="number">2</span>], to[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> tot, T, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	ne[++tot] = h[x];</span><br><span class="line">	h[x] = tot, to[tot] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tim, vis[N], match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = to[i];</span><br><span class="line">		<span class="keyword">if</span> (vis[y] == tim) <span class="keyword">continue</span>;</span><br><span class="line">		vis[y] = tim;</span><br><span class="line">		<span class="keyword">if</span> (!match[y] || dfs(match[y])) &#123;</span><br><span class="line">			match[y] = x; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">	<span class="built_in">memset</span>(ne, <span class="number">0</span>, <span class="keyword">sizeof</span>(ne));</span><br><span class="line">	<span class="built_in">memset</span>(to, <span class="number">0</span>, <span class="keyword">sizeof</span>(to));</span><br><span class="line">	<span class="built_in">memset</span>(match, <span class="number">0</span>, <span class="keyword">sizeof</span>(match));</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	T = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		pre();</span><br><span class="line">		n = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span> (x) &#123;</span><br><span class="line">				add(i, j + n); add(j + n, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">		tim++, ans += dfs(i);</span><br><span class="line">		<span class="keyword">if</span> (ans == n) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</p>
</details>



<hr>
]]></content>
      <categories>
        <category>图论</category>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S2019游记(NOINOI+CSTC)</title>
    <url>/2019/12/29/CSP-S2019%E6%B8%B8%E8%AE%B0-NOINOI-CSTC/</url>
    <content><![CDATA[<h1 id="CSP-S2019游记-NOI-NOI-CSTC"><a href="#CSP-S2019游记-NOI-NOI-CSTC" class="headerlink" title="CSP-S2019游记(NOI/NOI+/CSTC)"></a>CSP-S2019游记(NOI/NOI+/CSTC)</h1><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0:"></a>Day 0:</h2><p>早上听lhm讲图论, 终于完全掌握了dfs</p>
<p>火车上NO1给我们发了模拟赛,<del>(我是不可能做的, 这辈子都不可能的)</del> ,有点晕车</p>
<p>看了会JOJO,  又睡了会觉, 笑天大哥说我是睡觉大师</p>
<p>下午试机, 敲了敲fhq, 感觉机子有点慢但键盘海星, 回去的时候买了点特产(燕大的草稿本…</p>
<p>虚拟机和Windows共享的文件夹竟然是NOIP(它还没死)?!</p>
<p>不管,  睡了 </p>
<a id="more"></a>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1:"></a>Day 1:</h2><p>今天是 <del>NOI</del> CSP-S的第一天, 有点小紧张和小期待</p>
<p>压缩包密码输了5、6次才打开, 怕不是爆零的前奏吧</p>
<p>不过T1, T2是真滴简单</p>
<p>T1五分钟, T2半小时 其实T2的idea以前见过, 所以很快就切了</p>
<p>好, 剩下两个半小时可以全部搞T3了, 就是道紫题我也怎么拿个60的部分分吧</p>
<p>我经常说一句话, ztbNOIPday2T3能秒切, 我2019day1T3过60不是问题</p>
<p>埋伏他一手, 这个T3不着急, 这个T3大**,  我稳定了.</p>
<p>反手给一个枚举全排列, 闷声发大财.如果把时限换成1e正无穷, 这道题将秒杀, 但是换不得</p>
<p>怕不是2个小时过去了, 只对菊花图有一点点思路, 就是从1开始, 将到正确位置上的边确定顺序, 感觉细节太多很不好实现, 摸了</p>
<p>看一遍第二题大样例, 是一条链而且还是()()()()()()…., 反手就回去打对拍</p>
<p>day1: 205 大众分回家</p>
<p>洛谷上评测T3是黑题, 惊了</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2:"></a>Day 2:</h2><p>我一开题就笑了, 倒了一杯卡布奇诺, 怕不全是不可做题啊</p>
<p>T1只觉得是数学题, 不可做先摸了</p>
<p>T2只看出来是n^3dp, 摸了</p>
<p>T3想起以前做过一道求每棵子树重心的题, 那就从每个叶子跑一边O(n)啊</p>
<p>感觉能过75(实际只有25)</p>
<p>回去吧t2敲了敲, 感觉好像可以优化, 但脑抽了想到二分加线段树(其实不用线段树), 没来及敲</p>
<p>t1不会特别不可做吧, 赶紧瞪瞪</p>
<p>想半天数学方法好像不行, 憨憨的没往dp想</p>
<p>最后瞎敲了个dfs走人</p>
<p>感觉考试的状态不好, 脑子不在线</p>
<p>Day2: 0 (+?) + 36 + 25 ( + ?)</p>
<hr>
<p>感觉长了不少经验吧, 以后要多多做一些难题了</p>
<p>这次就是来划划水, 拿不拿省一不好说</p>
<p>不过挺值的, <del>毕竟只交了六分之一的钱就体验了一次NOI的感觉</del></p>
<p>预祝CSP-S2020 RP++</p>
<hr>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>CF437D The Child and Zoo</title>
    <url>/2019/12/29/CF437D-The-Child-and-Zoo/</url>
    <content><![CDATA[<p>模拟赛上出了此题， 大概是本蒟蒻唯一ac的题了</p>
<a id="more"></a>
<p>考场上第一眼康到这道题时， 因为只涉及路径上最小值最大的问题， 所以想到了货车运输， 跑出它的最大生成树，由最大生成树的性质可知， f(p, q） 必定在新建的树上的路径上</p>
<p>题目中让求所有点对的f值之和， 好像不太好求， 所以我们分别考虑每条边对答案的贡献。 先将树上的边按边权从大到小排序，使用并查集维护联通块的大小， 一个一个加边， 它对答案的贡献就是两端点联通块大小的乘积再乘上新边边权.</p>
<p>何哉？ 因为边权是从大到小排序的， 所以两联通块中的边权值均大于新边。 它的权值是最小的， 所以左端点所在联通块的点集到右端点所在联通块的点集的f值均为新边的边权。</p>
<p>最后， 发现最大生成树的过程和算答案的过程可以合并，详情见代码,还是很好理解的</p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">		c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1005000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;i) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> w &gt; i.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N], a[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> siz[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> f[x] = find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	read(n), read(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) f[i] = i, siz[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) read(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">		read(x), read(y);</span><br><span class="line">		e[i] = (node)&#123;x, y, min(a[x], a[y])&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(e + <span class="number">1</span>,e + m + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> fx = find(e[i].x), fy = find(e[i].y);</span><br><span class="line">		<span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">		f[fx] = fy;</span><br><span class="line">		ans += (<span class="keyword">long</span> <span class="keyword">long</span>)siz[fx] * siz[fy] * e[i].w;</span><br><span class="line">		siz[fy] += siz[fx];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">6</span>) &lt;&lt; (<span class="keyword">long</span> <span class="keyword">double</span>) ans * <span class="number">2</span>  / (<span class="keyword">long</span> <span class="keyword">double</span>)(n * (n<span class="number">-1</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>



<hr>
]]></content>
      <categories>
        <category>思路</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>并查集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>[Jsoi2015]染色问题 </title>
    <url>/2019/12/29/Jsoi2015-%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="一道比较简单的容斥题"><a href="#一道比较简单的容斥题" class="headerlink" title="一道比较简单的容斥题(?"></a>一道比较简单的容斥题(?</h3><p>可以容斥一下, 设$i, j ,k$分别代表$i$行有颜色, $j$行有颜色, 出现$k$种颜色的方案数</p>
<script type="math/tex; mode=display">
ans = \sum_{i=0}^n\sum_{j=0}^m\sum_{k=0}^c(-1)^{(i+j+k+n+m+c)}C_n^iC_m^jC_c^k(k+1)^{(n*m)}</script><p>k+1是因为一个格子可以不填颜色, 反手一个预处理组合数, O(n^3)稳过<br><a id="more"></a></p>
<details><summary>talk is cheap, show me the code</summary>
<p>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>;</span><br><span class="line">ll C[N][N], fpw[N*N];</span><br><span class="line"><span class="keyword">int</span> n, m, c;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">	fpw[<span class="number">0</span>] = C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">400</span>; i++) &#123;</span><br><span class="line">		C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i; j++) &#123;</span><br><span class="line">			C[i][j] = C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span> (C[i][j] &gt;= P) C[i][j] -= P;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> p = (n ^ m ^ c) &amp; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= c; k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n * m; i++) fpw[i] = fpw[i<span class="number">-1</span>] * (k+<span class="number">1</span>) % P;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m; j++) &#123;</span><br><span class="line">				ll res = C[n][i] * C[m][j] % P * C[c][k] % P * fpw[i*j] % P;</span><br><span class="line">				<span class="keyword">if</span> (((i ^ j ^ k) &amp; <span class="number">1</span>) ^ p) ans -= res;</span><br><span class="line">				<span class="keyword">else</span> ans += res;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (ans % P + P) % P &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p>
</details>



<hr>
]]></content>
      <categories>
        <category>数学</category>
        <category>容斥</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
</search>
